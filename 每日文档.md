# 2024/11/26

## 今日工作总结

​	今天完成了对于转化翻译（demo-trans）的demo的编写，对于转化翻译，首先有了一个较为宏观的认识：它主要完成的工作是对于实例对象进行翻译，所谓翻译，本质其实是对其进行字段诗句的补充。

```java
public class DogVO {
    //animalType字段是一个枚举类型的值，需要把它翻译为枚举类型的显示值，并把显示值放到animalTypeName字段;
    private String animalType;
    //例如：animalType本身值是DOG，他对应的animalTypeName就可能是dog，也可能是“狗”
    private String animalTypeName;
    //animalType字段是一个枚举类型的值，需要把它翻译为枚举对象，并把对象值放到animalEnum字段;
    private AnimalEnum animalEnum;
    //dictKey字段是一个字典类型的key，需要把它翻译为字典类型的value，并把value放到dictValue字段;
    private String dictKey;
    //例如：dictKey值为SubDictLabel，dictValue值为SubDictValue
    private String dictValue;
    //dictKey字段是一个字典类型的key，需要把它翻译为字典对象，并把值放到dictValueVO字段
    private DictVO dictValueVO;
    //testId字段是一个简单数据表类型的id，需要把它翻译为该Id数据对应的的name，并把name放到testName字段
    private String testId;
    //例如：testId值为90000，testName值为“测试翻译”
    private String testName;
    //testId字段是一个简单数据表类型的id，需要把它翻译为完整的数据对象，并把值放到user字段。
    private HashMap user;
}
```

 	比如上图的DogVO类型，赋值的时候可能只对其中的某几个字段进行赋值，如下图所示，但是一旦调用了@TransData注解进行标注，则说明该方法需要被翻译转化，那么系统就会自动根据翻译规则，对实例对象中的特定字段进行字段值的补充。

```java
@GetMapping("animal")
@TransData
public DogVO animal() throws Exception {
    DogVO vo = new DogVO();
    vo.setAnimalType(AnimalEnum.CAT.name());
    vo.setDictKey("SubDictLabel");
    vo.setTestId("90000");
    return vo;
}
```

​	需要注意的是，@TransData注解可以携带参数，完整代码如下。

​	其中，classType表示类名也就是规则名，一般为返回值的类型的基础类型，即包装类内部的类型，如代码2所示，他的classType就是DogVO，同时也可以不显示指定，那么系统就会默认是本方法的返回值类型，不会对包装类进行分析。

​	location表示可以显示的指定对象的位置，即在包装类中，可以自己手动指定需要对包装类内部的具体哪一部分进行转化翻译。如果不手动指定location，那么系统会进行默认的解包处理，但是存在解包失败的可能。

```java
//代码1
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
public @interface TransData {
    // 可以指定类名，即规则名
    String classType() default "";
    // 如果是多级嵌套对象，可以指定对象的位置，支持spel表达式
    String location() default "";
}
```

```java
//代码2
@GetMapping("/wrapper")
@TransData(classType = "org.example.DogVO")
ResponseVO<DogVO> testWrapper() {
    DogVO vo = new DogVO();
    vo.setAnimalType(AnimalEnum.DOG.name());
    vo.setDictKey("SubDictLabel");
    vo.setTestId("90001");

    return ResponseVO.ok(vo);
}
```

​	那么翻译规则该如何指定呢，比较简便且清晰的方式是使用代码和@TransRule注解进行指定，具体的翻译规则的示例如下所示。

```java
//(1) 在类上添加@Component注解，该注解的目的是让spring程序可以找到这个规则，否则该规则无法被应用
//(2)注意，下面的DogVORule是一个转换翻译的规则，因为被@TransRule注解标注
//其中ruleName表示规则名字，classType表示转换翻译对应的目标类(也就是可以翻译的类，对于本例子而言，只能翻译DogVO类)
//(3)在类上添加@Getter和@Setter注解，以便于可以对类的实例对象取值和赋值
//(4)在类上实现ITransRuleType接口，该接口是一个标记接口，没有任何方法，只是为了标记该类是一个转换翻译规则
//(5)在类中定义字段，字段的名称和类型要与目标类中的字段名称和类型一致
//(6) 在字段上添加@TransItem注解，表明该字段需要进行转换翻译， 其中transType表示转换翻译的类型，支持ENUM，DICT，TABLE
// assocObjName表示关联的对象名称，不同类型意义不同
// 类型为ENUM时，它为枚举类的全名；类型为DICT时，它为字典的分类；类型为TABLE时，为表名
//dstFieldName表示转换翻译后的字段名称，如果该字段为空，则返回整个对象
//dstParamTypes表示转换翻译后的字段类型； srcColumn表示源字段的名称，不同类型意义不同，类型为ENUM时，它无意义，可不配置；类型为DICT时，它为字典的Key；类型为TABLE时，为查询条件的字段名，如:id
//dstColumn表示目标字段的名称，可不配置。不同类型意义不同，类型为ENUM时，它为显示字段名；类型为DICT时，它为字典的值字段；类型为TABLE时，为select的字段名，如:name； servletContext只适用于rpc，为远程服务的servletContext； hostPort，当该字段不为空时，该转换会通过rpc调用方式进行转换，为目标主机的地址+端口号，或服务名。
@Component
@TransRule(ruleName = "TestDogVO", classType = DogVO.class)
@Getter
@Setter
public class DogVORule extends DogVO implements ITransRuleType {
    @TransItem(transType = TransType.ENUM, assocObjName = "org.example.AnimalEnum",
            dstFieldName = "animalTypeName", dstParamTypes = {String.class}, dstColumn = "desc")
    private String animalType;

    @TransItem(transType = TransType.DICT, assocObjName = "BIZ", srcColumn = "ParentDictLabel",
            dstFieldName = "dictValueVO", dstParamTypes = {DictVO.class})
    private String dictKey;

    @TransItem(transType = TransType.TABLE, assocObjName = "test_trans", srcColumn = "id",
            dstFieldName = "user", dstParamTypes = {HashMap.class})
    private String testId;
}
```

​	按照上述步骤，即可完成对于转化翻译注解的使用。



## 今日技巧学习及反思

### 1.@Autowired(required = false)

​	@Autowired注解是Spring框架中提供的一个注解，用于自动装配依赖，它可以将Spring容器中管理的Bean自动注入到需要的地方。

​	其中，required=false参数用于指定在找不到匹配的Bean时是否应该抛出异常。通常情况下，required的值是true，即如果找不到对应的Bean，会抛出异常，将required设置为true，表明某些依赖是可以选择的，如果找不到对应的Bean，程序依然可以正常运行。

### 2.测试——日志反思

​	在进行测试的时候，除了需要关注测试显示的结果，比如昨天的c端用户登录测试，除了需要观察是否登录成功，还需要观察日志文件的输出，尤其需要注意日志文件中的sql语句，要注意看sql语句查询的表是否正确，甚至连接的数据源是否正确，些许的小错误都可能导致bug的遗漏。