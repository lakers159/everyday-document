# 2024/11/26

## 今日工作总结

### 	转化翻译（demo-trans）

​	今天完成了对于转化翻译（demo-trans）的demo的编写，对于转化翻译，首先有了一个较为宏观的认识：它主要完成的工作是对于实例对象进行翻译，所谓翻译，本质是对其进行字段的补充。

```java
public class DogVO {
    //animalType字段是一个枚举类型的值，需要把它翻译为枚举类型的显示值，并把显示值放到animalTypeName字段;
    private String animalType;
    //例如：animalType本身值是DOG，他对应的animalTypeName就可能是dog，也可能是“狗”
    private String animalTypeName;
    //animalType字段是一个枚举类型的值，需要把它翻译为枚举对象，并把对象值放到animalEnum字段;
    private AnimalEnum animalEnum;
    //dictKey字段是一个字典类型的key，需要把它翻译为字典类型的value，并把value放到dictValue字段;
    private String dictKey;
    //例如：dictKey值为SubDictLabel，dictValue值为SubDictValue
    private String dictValue;
    //dictKey字段是一个字典类型的key，需要把它翻译为字典对象，并把值放到dictValueVO字段
    private DictVO dictValueVO;
    //testId字段是一个简单数据表类型的id，需要把它翻译为该Id数据对应的的name，并把name放到testName字段
    private String testId;
    //例如：testId值为90000，testName值为“测试翻译”
    private String testName;
    //testId字段是一个简单数据表类型的id，需要把它翻译为完整的数据对象，并把值放到user字段。
    private HashMap user;
}
```

​	比如上图的DogVO类型，赋值的时候可能只对其中的某几个属性进行赋值，如下图所示，但是一旦调用了@TransData注解进行标注，则说明该方法需要被翻译转化，那么系统就会自动根据翻译规则，对实例对象中的特定字段进行字段值的补充。

```java
@GetMapping("animal")
@TransData
public DogVO animal() throws Exception {
    DogVO vo = new DogVO();
    vo.setAnimalType(AnimalEnum.CAT.name());
    vo.setDictKey("SubDictLabel");
    vo.setTestId("90000");
    return vo;
}
```

​	需要注意的是，@TransData注解可以携带参数，完整代码如下。

​	其中，classType表示类名也就是规则名，一般为返回值的类型的基础类型，即包装类内部的类型，如代码2所示，他的classType就是DogVO，同时也可以不显示指定，那么系统就会默认是本方法的返回值类型，不会对包装类进行分析。

​	location表示可以显示的指定对象的位置，即在包装类中，可以自己手动指定需要对包装类内部的具体哪一部分进行转化翻译。如果不手动指定location，那么系统会进行默认的解包处理，但是存在解包失败的可能。

```java
//代码1
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
public @interface TransData {
    // 可以指定类名，即规则名
    String classType() default "";
    // 如果是多级嵌套对象，可以指定对象的位置，支持spel表达式
    String location() default "";
}
```

```java
//代码2
@GetMapping("/wrapper")
@TransData(classType = "org.example.DogVO")
ResponseVO<DogVO> testWrapper() {
    DogVO vo = new DogVO();
    vo.setAnimalType(AnimalEnum.DOG.name());
    vo.setDictKey("SubDictLabel");
    vo.setTestId("90001");

    return ResponseVO.ok(vo);
}
```

​	那么翻译规则该如何指定呢，比较简便且清晰的方式是使用代码和@TransRule注解进行指定，具体的翻译规则的示例如下所示。

```java
//(1) 在类上添加@Component注解，该注解的目的是让spring程序可以找到这个规则，否则该规则无法被应用
//(2)注意，下面的DogVORule是一个转换翻译的规则，因为被@TransRule注解标注
//其中ruleName表示规则名字，classType表示转换翻译对应的目标类(也就是可以翻译的类，对于本例子而言，只能翻译DogVO类)
//(3)在类上添加@Getter和@Setter注解，以便于可以对类的实例对象取值和赋值
//(4)在类上实现ITransRuleType接口，该接口是一个标记接口，没有任何方法，只是为了标记该类是一个转换翻译规则
//(5)在类中定义字段，字段的名称和类型要与目标类中的字段名称和类型一致
//(6) 在字段上添加@TransItem注解，表明该字段需要进行转换翻译， 其中transType表示转换翻译的类型，支持ENUM，DICT，TABLE
// assocObjName表示关联的对象名称，不同类型意义不同
// 类型为ENUM时，它为枚举类的全名；类型为DICT时，它为字典的分类；类型为TABLE时，为表名
//dstFieldName表示转换翻译后的字段名称，如果该字段为空，则返回整个对象
//dstParamTypes表示转换翻译后的字段类型； srcColumn表示源字段的名称，不同类型意义不同，类型为ENUM时，它无意义，可不配置；类型为DICT时，它为字典的Key；类型为TABLE时，为查询条件的字段名，如:id
//dstColumn表示目标字段的名称，可不配置。不同类型意义不同，类型为ENUM时，它为显示字段名；类型为DICT时，它为字典的值字段；类型为TABLE时，为select的字段名，如:name； servletContext只适用于rpc，为远程服务的servletContext； hostPort，当该字段不为空时，该转换会通过rpc调用方式进行转换，为目标主机的地址+端口号，或服务名。
@Component
@TransRule(ruleName = "TestDogVO", classType = DogVO.class)
@Getter
@Setter
public class DogVORule extends DogVO implements ITransRuleType {
    @TransItem(transType = TransType.ENUM, assocObjName = "org.example.AnimalEnum",
            dstFieldName = "animalTypeName", dstParamTypes = {String.class}, dstColumn = "desc")
    private String animalType;

    @TransItem(transType = TransType.DICT, assocObjName = "BIZ", srcColumn = "ParentDictLabel",
            dstFieldName = "dictValueVO", dstParamTypes = {DictVO.class})
    private String dictKey;

    @TransItem(transType = TransType.TABLE, assocObjName = "test_trans", srcColumn = "id",
            dstFieldName = "user", dstParamTypes = {HashMap.class})
    private String testId;
}	
```

​	除了直接通过代码配合@TransRule注解指定翻译规则，也可以通过数据库配置规则，在数据库中，规则与规则项对应的表分别为：sys_trans_rule和sys_trans_rule_item，合并后的视图为sys_trans_rule_view。 表中的各字段意义与代码实现相同。

​	按照上述步骤，即可完成对于转化翻译注解的使用。



## 今日技巧学习及反思

### @Autowired(required = false)

​	@Autowired注解是Spring框架中提供的一个注解，用于自动装配依赖，它可以将Spring容器中管理的Bean自动注入到需要的地方。

​	其中，required=false参数用于指定在找不到匹配的Bean时是否应该抛出异常。通常情况下，required的值是true，即如果找不到对应的Bean，会抛出异常，将required设置为true，表明某些依赖是可以选择的，如果找不到对应的Bean，程序依然可以正常运行。

### 测试——日志反思

​	在进行测试的时候，除了需要关注测试显示的结果，比如昨天的c端用户登录测试，除了需要观察是否登录成功，还需要观察日志文件的输出，尤其需要注意日志文件中的sql语句，要注意看sql语句查询的表是否正确，甚至连接的数据源是否正确，些许的小错误都可能导致bug的遗漏。

### VO、Entity的区别

​	这三个是前端、后端、数据库进行数据传递的数据类，其中，VO是前后端之间相互交互的数据类。但是，则这不代表前后端之间相互传递的VO是完全一致的，以学生Student举例，前端给后端传递的可能是StudentParamVO，而后端给前端传递的是StudentVO。Entity是实体类，每一个数据表都对应一个实体类，数据表中的每一个字段都对应实体类中的每一个属性。



# 2024/11/27

## 今日工作总结

​	今天完成utils工具类的代码学习，同时进行了注释和文档的编写。

### AppUtil工具类

​	@SneakyThrows是Lombok提供的注解，用于自动处理方法中可能抛出的异常，而不需要在方法签名中显式声明**throws**。

```java
//AppUtil工具类主要就是在应用程序启动的时候打印应用长须的相关信息，包括应用程序的名称、本地和外部访问地址，以及Swagger文档的访问地址，便于开发人员调试，打印结果如下所示
//	Application DemoMybatisplusStandaloneApp is running! Access URLs:
//            Local: 		http://localhost:8080/
//            External: 	http://10.2.5.150:8080/
//            Swagger文档: 	http://10.2.5.150:8080/doc.html
public class AppUtil {
    @SneakyThrows
    public static void printAppInfo(Class<?> clazz, ConfigurableApplicationContext context) {
        Environment env = context.getEnvironment();
        String ip = InetAddress.getLocalHost().getHostAddress();
        String port = env.getProperty("server.port");
        String path = env.getProperty("server.servlet.context-path");
        String servletContent = StrUtil.isNotBlank(path) ? path : "";
        log.info("\n----------------------------------------------------------\n\t" +
                "Application " + clazz.getSimpleName() + " is running! Access URLs:\n\t" +
                "Local: \t\thttp://localhost:" + port + servletContent + "/\n\t" +
                "External: \thttp://" + ip + ":" + port + servletContent + "/\n\t" +
                "Swagger文档: \thttp://" + ip + ":" + port + servletContent + "/doc.html\n" +
                "----------------------------------------------------------");
    }
}
```

​	

### BaseSqlUtil工具类

​	BaseSqlUtil工具类用于数据库字段名和Java对象属性名之间的相互转化，标准规范下，数据库字段名应该使用下划线的形式，即user_name，Java对象属性名应该采用驼峰命名的形式,即userName。

```java
//这个工具类用于数据库字段名和Java对象属性名之间进行转换
public class BaseSqlUtil {
    //buildColumnName方法是将Java对象属性名转换为数据库字段名，如果camelCase为true，则表示需要进行驼峰转换，即将驼峰命名转换为下划线命名。
    public static String buildColumnName(boolean camelCase, String fieldName) {
        String columnName = fieldName;
        if (camelCase) {
            columnName = StrUtil.toUnderlineCase(columnName);
        }

        return columnName;
    }

    //buildFieldName方法是将数据库的字段名转换为Java对象的属性名，如果camelCase为true，则表示需要进行驼峰转换，即将下划线命名转换为驼峰命名。
    public static String buildFieldName(boolean camelCase, String columnName) {
        String fieldName = columnName;
        if (camelCase) {
            fieldName = StrUtil.toCamelCase(fieldName.toLowerCase());
        }

        return fieldName;
    }
}
```

### 	ColumnUtil工具类

​	下面的方法十分的巧妙，通过反射获取某一个实体对象的getter、setter、is类型的方法，进而获取它的Java对象属性名，最后将Java对象的属性名转化为数据库中的字段名。

```java
//先通过的反射获取Java对象的属性名，再将Java对象的属性名转化为数据库的字段名
public class ColumnUtil {
    //get方法的前缀
    public static final String GET_PREFIX = "get";
    //set方法的前缀
    public static final String SET_PREFIX = "set";
    //Boolean类型的get方法的前缀
    public static final String IS_PREFIX = "is";

    //先通过的反射获取Java对象的属性名，再将Java对象的属性名转化为数据库的字段名
    public static <T extends IAbstractEntity> String getColumnName(boolean camelCase, IEntityGetter<T, ?> getter) throws Exception {
        //从get，set，is方法中获取Java对象的属性名
        String fieldName = getFieldName(getter);
        //将Java对象的属性名转化为数据库的字段名
        String columnName = BaseSqlUtil.buildColumnName(camelCase, fieldName);

        return columnName;
    }

    public static <T extends IAbstractEntity> String getFieldName(IEntityGetter<T, ?> getter) throws Exception {
        //获取方法名
        String methodName = getMethodName(getter);
        //如果方法是get方法或者set方法，去掉前缀（get或者set）并把首字母小写，便于转化为字段名
        if (methodName.startsWith(GET_PREFIX) || methodName.startsWith(SET_PREFIX)) {
            return StrUtil.removePreAndLowerFirst(methodName, 3);
        } else if (methodName.startsWith(IS_PREFIX)) {//如果是is方法，去掉前缀（is）并把首字母小写，便于转化为字段名
            return StrUtil.removePreAndLowerFirst(methodName, 2);
        } else {
            throw new IllegalArgumentException("Invalid Getter name: " + methodName);
        }
    }


    public static <T extends IAbstractEntity> String getMethodName(IEntityGetter<T, ?> getter) throws Exception {
        //调用SerializedLambda类型的getImplMethodName方法，主要是为了获取IEntityGetter对象实际的方法名
        String methodName = getSerializedLambda(getter).getImplMethodName();

        return methodName;
    }

    //返回一个lambda表达式中提取的序列化形式，这个序列化形式包含了lambda表达式的实现类、方法名等信息
    public static <T extends IAbstractEntity> SerializedLambda getSerializedLambda(IEntityGetter<T, ?> getter) throws Exception {
        //获取getter对象的类中的名字是writeReplace的方法，所以现在method就是writeReplace方法
        Method method = getter.getClass().getDeclaredMethod("writeReplace");
        //设置方法可以访问，因为一般情况下writeReplace方法是私有的
        method.setAccessible(true);
        //调用writeReplace方法，返回值是SerializedLambda对象
        SerializedLambda lambda = (SerializedLambda) method.invoke(getter);

        return lambda;
    }

    //getterMethodName可以将Java对象的属性名转化为getter方法名
    public static String getterMethodName(String fieldName) {
        String name = null;

        if (StrUtil.isNotBlank(fieldName)) {
            name = GET_PREFIX + StrUtil.upperFirst(fieldName);
        }

        return name;
    }

    //setterMethodName可以将Java对象的属性名转化为setter方法名
    public static String setterMethodName(String fieldName) {
        String name = null;

        if (StrUtil.isNotBlank(fieldName)) {
            name = SET_PREFIX + StrUtil.upperFirst(fieldName);
        }

        return name;
    }
}
```



### CommonIpAddressUtil工具类

​	CommonIpAddressUtil工具类中的getIp方法返回HttpServletRequest参数中的IP地址

```java
public class CommonIpAddressUtil {
    private static final String LOCAL_REMOTE_HOST = "0:0:0:0:0:0:0:1";

    /**
     * 获取客户端ip
     */
    //getIp返回一个String类型的IP地址
    public static String getIp(HttpServletRequest request) {
        if (ObjectUtil.isEmpty(request)) {
            //request对象为空的话，直接返回本地回环地址127.0.0.1
            return Ipv4Util.LOCAL_IP;
        } else {
            try {
                //getClientIP方法会返回客户端的IP地址
                String remoteHost = JakartaServletUtil.getClientIP(request);
                //如果客户端的IP地址是本地回环地址，则返回127.0.0.1，否则直接返回客户端的IP地址
                return LOCAL_REMOTE_HOST.equals(remoteHost) ? Ipv4Util.LOCAL_IP : remoteHost;
            } catch (Exception e) {
                log.error(">>> 获取客户端ip异常：", e);
                return Ipv4Util.LOCAL_IP;
            }
        }
    }
}
```

​	

### getParamFromRequest工具类

​	getParamFromRequest工具类主要负责HTTP相关的处理

```java
public class CommonServletUtil {

    /**
     * 从请求中中获取参数
     **/
    //paramName表示要获取的参数名字，最终返回一个paramValue，也就是参数值
    public static String getParamFromRequest(String paramName) {
        //获取当前线程下的HttpServletRequest对象
        HttpServletRequest request = getRequest();

        // 1. 尝试从请求体里面读取
        String paramValue = request.getParameter(paramName);

        // 2. 尝试从header里读取，前提是从请求体里面读取paramValue值为空
        if (ObjectUtil.isEmpty(paramValue)) {
            paramValue = request.getHeader(paramName);
        }
        // 3. 尝试从cookie里读取，前提是paramValue值为空
        if (ObjectUtil.isEmpty(paramValue)) {
            Cookie[] cookies = request.getCookies();
            if(ObjectUtil.isNotEmpty(cookies)) {
                for (Cookie cookie : cookies) {
                    String cookieName = cookie.getName();
                    if (cookieName.equals(paramName)) {
                        return cookie.getValue();
                    }
                }
            }
        }
        // 4. 返回
        return paramValue;
    }

    //getRequest方法是在当前的线程下，获取HttpServletRequest类型的对象
    public static HttpServletRequest getRequest() {
        ServletRequestAttributes servletRequestAttributes;
        try {
            //获取当前的ServletRequestAttributes对象
            servletRequestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("非Web上下文无法获取Request");
        }
        if (servletRequestAttributes == null) {
            throw new RuntimeException("非Web上下文无法获取Request");
        } else {
            return servletRequestAttributes.getRequest();
        }
    }

    //getResponse方法是在当前的线程下，获取HttpServletResponse类型的对象
    public static HttpServletResponse getResponse() {
        ServletRequestAttributes servletRequestAttributes;
        try {
            //获取当前的ServletRequestAttributes对象
            servletRequestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("非Web上下文无法获取Response");
        }
        if (servletRequestAttributes == null) {
            throw new RuntimeException("非Web上下文无法获取Response");
        } else {
            return servletRequestAttributes.getResponse();
        }
    }

    public static boolean isWeb() {
        return RequestContextHolder.getRequestAttributes() != null;
    }

    /**
     * 在响应中设置允许跨域访问
     * @param response
     */
    //setCors方法的主要目的是在响应中设置跨域资源共享的相关头信息，进而允许跨域访问
    public static void setCors(HttpServletResponse response, Integer maxAge) {
        // 允许指定域访问跨域资源
        response.setHeader("Access-Control-Allow-Origin", "*");
        // 允许所有请求方式
        response.setHeader("Access-Control-Allow-Methods", "POST, GET, OPTIONS, DELETE");
        // 有效时间
        response.setHeader("Access-Control-Max-Age", String.valueOf(maxAge));
        // 允许的header参数
        response.setHeader("Access-Control-Allow-Headers", "*");
        // 是否启用浏览器默认XSS防护： 0=禁用 | 1=启用 | 1; mode=block 启用, 并在检查到XSS攻击时，停止渲染页面
        response.setHeader("X-XSS-Protection", "1; mode=block");
        // 禁用浏览器内容嗅探
        response.setHeader("X-Content-Type-Options", "nosniff");
    }
}
```



### CommonUaUtil工具类

​	CommonUaUtil主要是为了解析和获取客户端用户代理(User Agent)，进而获取客户端的操作系统和浏览器信息。

```java
/**
 * 用户代理工具类
 */
//CommonUaUtil主要是为了解析和获取客户端用户代理(User Agent)，进而获取客户端的操作系统和浏览器信息。
public class CommonUaUtil {

    /**
     * 获取客户端浏览器
     */
    public static String getBrowser(HttpServletRequest request) {
        //获取代理对象
        UserAgent userAgent = getUserAgent(request);
        if (ObjectUtil.isEmpty(userAgent)) {
            return StrUtil.DASHED;
        } else {
            String browser = userAgent.getBrowser().toString();
            //返回浏览器名称
            return "Unknown".equals(browser) ? StrUtil.DASHED : browser;
        }
    }

    /**
     * 获取客户端操作系统
     */
    public static String getOs(HttpServletRequest request) {
        UserAgent userAgent = getUserAgent(request);
        if (ObjectUtil.isEmpty(userAgent)) {
            return StrUtil.DASHED;
        } else {
            String os = userAgent.getOs().toString();
            //返回操作系统名称
            return "Unknown".equals(os) ? StrUtil.DASHED : os;
        }
    }

    /**
     * 获取请求代理头
     */
    private static UserAgent getUserAgent(HttpServletRequest request) {
        //获取User-Agent的头信息
        String userAgentStr = JakartaServletUtil.getHeaderIgnoreCase(request, "User-Agent");
        //解析userAgentStr对象
        UserAgent userAgent = UserAgentUtil.parse(userAgentStr);
        if (ObjectUtil.isNotEmpty(userAgentStr)) {
            //遇到未知的浏览器，创建一个新的Browser对象，同时将其设置进userAgent对象中
            if ("Unknown".equals(userAgent.getBrowser().getName())) {
                userAgent.setBrowser(new Browser(userAgentStr, null, ""));
            }
        }
        return userAgent;
    }
}
```



### EmailUtil工具类

​	EmailUtil是验证电子邮件格式是否有效的工具类

```java
//验证电子邮件格式的工具类
public class EmailUtil {
    //校验电子邮件地址是否有效
    public static boolean isEmail(String email) {
        return  Validator.isEmail(email);
    }

    /**
     * 校验邮箱格式
     *
     * @author xuyuxiang
     * @date 2022/8/15 13:32
     **/
    //可以接受一个字符串中有多个电子邮件的地址
    public static void validEmail(String emails) throws Exception {
        //按照“，”将emails中的多个电子邮件拆分开，然后对每一个电子邮件进行验证
        StrUtil.split(emails, StrUtil.COMMA).forEach(email -> {
            if(!isEmail(email)) {
                throw new InvalidParameterException("邮件地址：" + email + "格式错误");
            }
        });
    }
}
```



### EntityVOConvertUtil工具类

​	EntityVOConvertUtil实现Entity和VO

```java
//EntityVOConvertUtil工具类实现Entity和VO之间的相互转化
public class EntityVOConvertUtil {
    //bean2Entity方法将paramVO对象转化为Entity对象，注意，这里是创建了一个新的entity对象
    public static <E extends IAbstractEntity> E bean2Entity(AbstractParamVO paramVO, Class<E> clazz, IParam2EntityCallback callback) throws Exception {
        E entity = null;

        if (null != paramVO) {
            //使用反射创建实例对象
            entity = clazz.getConstructor(new Class[]{}).newInstance();
            //将paramVO的属性复制到entity中
            BeanUtil.copyProperties(paramVO, entity);
            //使用回调函数处理paramVO和entity，对entity中的属性值进行自定义处理
            if (null != callback) {
                callback.param2EntityCallback(paramVO, entity);
            }
        }

        return entity;
    }

    //beanCopyEntity方法将paramVO对象的属性复制到entity对象中，注意，这里是直接对entity对象进行修改
    public static <E extends IAbstractEntity> E beanCopyEntity(AbstractParamVO paramVO, IAbstractEntity entity, IParam2EntityCallback callback) throws Exception {
        //对属性进行复制
        BeanUtil.copyProperties(paramVO, entity);
        //使用回调函数进行处理paramVO和entity，对entity中的属性值进行自定义处理
        if (null != callback) {
            callback.param2EntityCallback(paramVO, entity);
        }

        return (E) entity;
    }

    //entity2Vo方法将entity对象转化为VO对象，注意，这里是创建了一个新的vo对象
    public static <V extends AbstractVO> V entity2Vo(IAbstractEntity entity, Class<V> clazz, IEntity2VoCallback callback) throws Exception {
        V vo = null;

        if (null != entity) {
            //创建一个新的VO对象
            vo = clazz.getConstructor(new Class[]{}).newInstance();
            BeanUtil.copyProperties(entity, vo);
            if (null != callback) {
                callback.entity2VoCallback(entity, vo);
            }
        }

        return vo;
    }

    //entities2Vos方法将entity对象列表转化为VO对象列表，注意，这里是创建了一个新的vo对象列表
    public static <V extends AbstractVO> List<V> entityList2VoList(List<? extends IAbstractEntity> entities, Class<V> clazz, IEntities2VosCallback callback) throws Exception {
        Constructor<V> constructor = clazz.getConstructor(new Class[]{});
        List<V> kList = null;
        if (null != entities) {
            kList = new ArrayList<>();
            for (IAbstractEntity e : entities) {
                V vo = constructor.newInstance();
                BeanUtil.copyProperties(e, vo);
                kList.add(vo);
            }
        }

        if (null != callback) {
            callback.entities2VosCallback(entities, kList);
        }

        return kList;
    }

    //将IdParamVO对象列表转化为id字符串列表，原本的IdParamVO对象列表中的每个对象都有一个id属性，现在将这些id属性提取出来，形成一个新的id字符串列表
    public static List<String> idParam2IdList(List<IdParamVO> idParamVOS) {
        List<String> idList = null;

        if (null != idParamVOS) {
            idList = CollStreamUtil.toList(idParamVOS, IdParamVO::getId);
        }

        return idList;
    }

    //entityPage2VoPage将entity的分页对象转化为VO的分页对象，最终返回一个分页的VO对象
    //这里的page是分页实体对象
    public static <V extends AbstractVO, E extends IAbstractEntity> PageVO<V> entityPage2VoPage(PageVO<E> page,
                                                                                                Class<V> clazz, IEntities2VosCallback entities2VosCallback) throws Exception {
        PageVO<V> pageVO = null;

        if (null != page) {
            //获取分页实体对象的行列表getRows
            List<E> eList = page.getRows();
            List<V> voList = entityList2VoList(eList, clazz, entities2VosCallback);
            //将entity的分页对象转化为VO的分页对象
            pageVO = new PageVO<>(page.getPageSize(), page.getCurrentPage(), page.getTotalRecord(), page.getTotalPage(), voList);
        }

        return pageVO;
    }
}
```



### IdGenerator工具类

​	IdGenerator类主要实现雪花算法生成id

```java
/**
 * snowflake理论情况下单机可实现每秒409.6万个id 的生成上限，实际上业务上不可能达到如此高的并发
 * 那么就会存在过去的一段时间内，有大量的时间戳浪费，达不到该上限，可能在某一毫秒只会生成几个id，
 * 如果发生时间回退，这些浪费的时间戳是不是就能被利用起来，而不是抛出异常
 * 如果在内存中建立一个数组，数组设置固定的长度，比如 200 ，数组中存储上一次对应位置的毫秒数据的id,
 * 那么就能在时间回退到追回时间段内，再至多提供819200 （2^12）* 200个id,
 * 如果发生时间回退，就只用在上次id 上进行 +1 操作。直到系统时间被追回。
 */
@Slf4j
public class IdGenerator {
    /**
     * 最大的MachineId
     */
    private static final long MAX_MACHINE_ID = 1023L;

    /**
     * AtomicLongArray环的大小，可以保存200毫秒内，没个毫秒数上的上一次id，时间回退依赖于此
     */
    private static final int CAPACITY = 200;

    /**
     * 时间戳在id中左移的位数
     */
    private static final int TIMESTAMP_SHIFT_COUNT = 22;

    /**
     * 机器码在id中左移的位数
     */
    private static final int MACHINE_ID_SHIFT = 12;

    /**
     * 序列号的掩码 2^12
     */
    private static final long SEQUENCE_MASK = 4095L;

    /**
     * id 开始时间戳，世界初始之日 2024-01-01
     */
    private static long START_THE_WORLD_MILLIS = 1704038400000L;


    private static final IdGenerator idGenerator = new IdGenerator();

    private IdGenerator() {

    }

    public static IdGenerator getInstance() {
        return idGenerator;
    }

    private static final AtomicLongArray messageIdCycle = new AtomicLongArray(CAPACITY);


    /**
     * 生成id的核心代码
     *
     * @return
     */
    public long genId(long machineId) {
        do {
            // 机器码不能超过最大值 且 不能小于0
            if (machineId <= 0 || machineId > MAX_MACHINE_ID) {
                throw new RuntimeException("the machine id is out of range,it must between 1 and 1023");
            }

            // 获取当前时间戳，由当前系统时间戳 - 系统启动的时间
            long timestamp = System.currentTimeMillis() - START_THE_WORLD_MILLIS;

            // 获取当前时间在messageIdCycle中的下标，用于获取环找那个上一个messageId
            int index = (int) (timestamp % CAPACITY);
            long idInCycle = messageIdCycle.get(index);

            // 通过messageIdCycle 计算上一个Id的时间戳
            long timestampInCycle = idInCycle >> TIMESTAMP_SHIFT_COUNT;
            // 如果没有设置时间戳，或者时间戳小于当前时间，则重新设置新的时间戳
            if (idInCycle == 0 || timestampInCycle < timestamp) {
                long id = (timestamp << TIMESTAMP_SHIFT_COUNT) | (machineId << MACHINE_ID_SHIFT);
                if (messageIdCycle.compareAndSet(index, idInCycle, id)) {
                    return id;
                }
            }

            //如果当前时间戳与messageIdCycle的时间戳相等，使用环中的id + 1 生成新的id
            //如果发生了时间回退情况，即（timestampInCycle > timestamp）,那么不能更新MessageIdCycle的时间戳。
            // 时间回退,
            if (timestampInCycle >= timestamp) {
                long sequence = idInCycle & SEQUENCE_MASK;
                if (sequence >= SEQUENCE_MASK) {
                    log.debug("over sequence mask :{}", sequence);
                    continue;
                }
                long messageId = idInCycle + 1;
                if (messageIdCycle.weakCompareAndSetVolatile(index, idInCycle, messageId)) {
                    return messageId;
                }
            }
        } while (true);
    }
}
```



### ReflectExUtil工具类

​	ReflectExUtil工具类通过反射获取和设置属性值

```java
//ReflectExUtil工具类通过反射获取和设置属性值
public class ReflectExUtil {
    public static void setFieldValue(Object obj, String fieldName, Object value) throws UtilException {
        Assert.notNull(obj);
        Assert.notBlank(fieldName);

        final Field field = ReflectUtil.getField((obj instanceof Class) ? (Class<?>) obj : obj.getClass(), fieldName);
        if (null != field) {
            ReflectUtil.setFieldValue(obj, field, value);
        }
    }
}
```



## 今日技巧学习及反思

### CORS（跨域资源共享）

具体文章参考：[什么是 CORS ？一文搞懂 CORS 跨域原理！零基础入门到精通，收藏这一篇就够了-CSDN博客](https://blog.csdn.net/leah126/article/details/141624726)

### XSS攻击及防御

具体文章参考：[XSS（跨站攻击）-CSDN博客](https://blog.csdn.net/huangyongkang666/article/details/123624164?ops_request_misc=%7B%22request%5Fid%22%3A%2224366998c267f79a08c54a190b425cbc%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=24366998c267f79a08c54a190b425cbc&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123624164-null-null.142^v100^pc_search_result_base3&utm_term=xss&spm=1018.2226.3001.4187)

### Validator类中isEmail方法

具体文章参考：[validator中isEmail详细介绍_validator.isemail-CSDN博客](https://blog.csdn.net/zhupengfei/article/details/109197258?ops_request_misc=%7B%22request%5Fid%22%3A%22ab316580549bf86dcdce078a7cc0f8c2%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=ab316580549bf86dcdce078a7cc0f8c2&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-109197258-null-null.142^v100^pc_search_result_base3&utm_term=Validator.isEmail&spm=1018.2226.3001.4187)





# 2024/11/28

## 今日工作总结

### 验证码的扩展

​	今天实现了验证码的扩展，主要方式是通过扩展了滑动验证码（直接将验证码写死为1234），然后通过配置切换的方式，即可完成验证码的扩展与切换。

​	具体方式为扩展com.jezetek.commonframework.auth.service.ICaptchaService类，实现相应的接口函数即可。如下例所示，就是具体扩展ICaptchaService类的方式，下面的注解是对于SlidingCaptchaServiceImpl实现的配置类，由于是作为测试，所以SlidingCaptchaConfiguration内部并没有任何的实现，空类即可。

```java
@ConditionalOnBean(value = {SlidingCaptchaConfiguration.class})
```

​	@ConditionalOnProperty(value = "commonframework.auth.slidingCaptchaService.enabled", havingValue = "true", matchIfMissing = true)是校验配置auth.yml配置文件中是否设置了slidingCaptchaService为打开状态，打开了配置文件中的开关，即可使用SlidingCaptchaServiceImpl。配置文件也一并附上。

```java
@Service
@Slf4j
@ConditionalOnBean(value = {SlidingCaptchaConfiguration.class})
@ConditionalOnProperty(value = "commonframework.auth.slidingCaptchaService.enabled", havingValue = "true", matchIfMissing = true)
public class SlidingCaptchaServiceImpl implements ICaptchaService, InitializingBean {
    //getType是获取验证码类型，本次扩展的是滑动验证码（没有具体实现，直接将验证码内容写死为1234），即SlidingCaptcha
    @Override
    public String getType() {
        return "SlidingCaptcha";
    }

    //配置验证码的相关信息，即captchaInfo
    @Override
    public CaptchaInfo makeCaptcha() {
        CaptchaInfo captchaInfo = new CaptchaInfo();
        captchaInfo.setCaptcha(null);
        //直接设置验证码的值
        captchaInfo.setValidData("1234");
        //设置验证码的类型
        captchaInfo.setType(getType());

        log.info("sliding的makeCaptcha被调用");
        return captchaInfo;
    }

    //validCaptchaData是验证验证码是否正确，即验证码的值是否与设置的值一致
    @Override
    public boolean validCaptchaData(CaptchaInfo captchaInfo, String validData) throws Exception {
        log.info("sliding的validCaptchaData被调用");
        Assert.notNull(captchaInfo);
        Assert.notEmpty(validData);

        //判断验证码的值是否与设置的值一致
        if (validData.equals(captchaInfo.getValidData())) {
            return true;
        }

        return false;
    }

    //验证配置文件是否配置成功
    @Override
    public void afterPropertiesSet() throws Exception {
        log.info(this.getClass().getSimpleName() + " initialized .");
    }
}
```

```java
# 验证码相关配置
captcha:
  # 是否启用
  enabled: true
  # 过期时间
  expireSecs: 60
  #	滑动验证码相关配置
  sliding-captcha:
    # 是否启用
    enabled: true
```



## 今日技巧学习及反思

### GET请求的参数设置

​	在测试http请求类型为GET的时候，GET请求的参数应该会跟在url的后面，设置在query或者body上都可以，但是不可以设置在head上。

### 用户登录流程思考

​	用户登录的流程是一个值得关注的问题，尤其是因为涉及到和数据库的交互以及给前端返回信息的时效性问题。

​	对于用户登录而言，首先前端会给后端传递一个用户输入的登录信息，这个登录信息中含有必要的账号、密码、验证码等作为登录检验的手段。此时后端会接受到前端传递的信息，然后会根据用户的账号对数据库进行查询，查询数据库中是否有对应的账号信息，**注意！**此时理论上已经可以获得对应账号的数据库信息，比如账号、密码、登录设备的类型、上一次登录时间、用户是否被禁用等等信息。但是这时候不应该直接将信息保存并传递给前端，因为登录成功之后，数据库中的用户信息一定会被更改（一般情况下,用户表中都会有lastest_logintime,也就是最近一次登录时间，这个信息是会因为用户登录成功而被实时更新的）。所以，在用户登录成功之后，首先会对数据库中的user表进行更新，同时，返回给前端的信息也需要重新查询。

​	综上，用户登录最精简的步骤，是select+update+selest，三次对数据库进行操作。



### Sa-Token

​	下面的是Sa-Token配置文件，按照yml文件为例子。

```yaml
server:
    # 端口
    port: 8081
    
############## Sa-Token 配置 (文档: https://sa-token.cc) ##############
sa-token: 
    # token 名称（同时也是 cookie 名称）
    token-name: satoken
    # token 有效期（单位：秒） 默认30天，-1 代表永久有效
    timeout: 2592000
    # token 最低活跃频率（单位：秒），如果 token 超过此时间没有访问系统就会被冻结，默认-1 代表不限制，永不冻结
    active-timeout: -1
    # 是否允许同一账号多地同时登录 （为 true 时允许一起登录, 为 false 时新登录挤掉旧登录）
    is-concurrent: true
    # 在多人登录同一账号时，是否共用一个 token （为 true 时所有登录共用一个 token, 为 false 时每次登录新建一个 token）
    is-share: true
    # token 风格（默认可取值：uuid、simple-uuid、random-32、random-64、random-128、tik）
    token-style: uuid
    # 是否输出操作日志 
    is-log: true
```

​	Sa-Token官网，很值得一看：https://sa-token.cc/doc.html#/use/login-auth





# 2024/12/2

## 今日工作总结

### 二叉树每一层的平均值

```java
//二叉树结构
public class TreeNode {
      int val;
      TreeNode left;
      TreeNode right;
      TreeNode() {}
      TreeNode(int val) { this.val = val; }
      TreeNode(int val, TreeNode left, TreeNode right) {
          this.val = val;
          this.left = left;
          this.right = right;
      }
  }
 
//二叉树的层次遍历
class Solution {
    public List<Double> averageOfLevels(TreeNode root) {
        //用于广度优先算法收集的队列
        Queue<TreeNode> queue=new LinkedList<>();
        queue.add(root);

        //用于保存结果的动态数组
        List<Double> result=new ArrayList<>();

        double tempSum;//临时变量，记录每层节点的相加的总和
        int tempCount;//临时变量，记录每层节点的个数
        TreeNode tempNode;//临时变量，方便进行广度优先遍历

        while(!queue.isEmpty()){//队列不为空的情况下进入循环,每一次循环代表遍历一层
            tempSum=0.0;
            tempCount=queue.size();
            for(int i=0;i<tempCount;i++){
                tempNode=queue.poll();
                if(tempNode.left!=null){
                    queue.offer(tempNode.left);
                }
                if(tempNode.right!=null){
                    queue.offer(tempNode.right);
                }        
                tempSum=tempSum+tempNode.val;//将每一层的节点值相加       
            }
            result.add(tempSum/tempCount);//计算平均值，并加入集合中
        }
        return  result;
    }
}
```

​	广度优先搜索使用队列存储待访问节点，只要确保在每一轮遍历时，队列中的节点是同一层的全部节点即可。具体做法如下：

​	初始时，将根节点加入队列；每一轮遍历时，将队列中的节点全部取出，计算这些节点的数量以及它们的节点值之和，并计算这些节点的平均值，然后将这些节点的全部非空子节点加入队列，重复上述操作直到队列为空，遍历结束。由于初始时队列中只有根节点，满足队列中的节点是同一层的全部节点，每一轮遍历时都会将队列中的当前层节点全部取出，并将下一层的全部节点加入队列，因此可以确保每一轮遍历的是同一层的全部节点。具体实现方面，可以在每一轮遍历之前获得队列中的节点数量 size，遍历时只遍历 size 个节点，即可满足每一轮遍历的是同一层的全部节点。



## 今日技巧学习及反思

```java
Queue<TreeNode> queue = new LinkedList<>();
```

​	上面的语句是创建一个队列的语句，LinkedList本身是一个双向链表，这意味着每个元素都包含一个指向前一个元素和后一个元素的指针。这使得在队列的两端，前端和后端进行插入和删除操作都是非常高效的。LinkedList本身是一个动态数据结构，可以根据需要自动调整大小，不需要预先指定容量。但是LinkedList不是线程安全的，如果在多线程环境中使用，需要进行同步处理。

​	LinkedList实现了Queue接口，因此可以使用Queue接口中定义的方法：

1.添加元素

​	boolean add(E e):将制定的元素插入队列，如果成功则返回true，如果队列已满则抛出异常。

​	boolean offer(E e):将制定的元素插入队列，如果成功则返回true，如果队列已满则返回false。

2.移除元素

​	E remove():检索并移除队列的头元素，如果队列为空则抛出异常。

​	E poll():检索并移除队里的头元素，如果队列为空则返回null。

3.查看元素

​	E element():检索但不移除队列的头元素，如果队列为空则抛出异常。

​	E peek():检索但不移除队列的头元素，如果队列为空则返回null。



# 2024/12/3

## 今日工作总结

### RBAC模型

​	今天完成了用户、角色的授予权限的操作，出现了一些问题，同时也阅读了相关的文献[RBAC——基于角色权限的模型-CSDN博客](https://blog.csdn.net/m0_62006803/article/details/133962328?ops_request_misc=%7B%22request%5Fid%22%3A%22469a602f4a94794268f624b05eee29aa%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=469a602f4a94794268f624b05eee29aa&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-133962328-null-null.142^v100^pc_search_result_base3&utm_term=rbac&spm=1018.2226.3001.4187)

​	基于上述阅读的文献，我对RBAC用户-角色-权限模型有了更加深刻的认识，下面简单谈一谈个人对与RBAC角色模型的看法。

#### 为什么要有角色？

​	为什么要有角色，直接对用户授权不可以吗？答案显然是可以的，但是会带来一些问题，其中最为显著的问题就是过度的重复操作。试想，当用户的数量非常大的时候，要给系统中的每一个用户逐一授权，是一件非常繁琐的事情。这时候比较好的解决方案就是对用户进行分组，将权限一样的用户分到一个用户组内。这其实就用到了角色的思想，因为一个用户组内的用户权限一致，那么就可以直接对整个用户组进行授权，类似对某个角色进行授权，再将角色分配给用户。

#### 用户、角色、权限三者关系

​	用户和角色之间，角色和权限之间一般为多对多的关系。因为一个用户可能身兼多职，就会拥有多个角色。	用户和权限之间一般没有直接的联系，但是也存在为了灵活性的角度考虑，主要是考虑某些用户可能会有一些临时的权限，会给用户和权限之间打开一条通路（即可以不通过角色进行中转，直接对用户进行授权）。如果实在这种情况下，用户所拥有的权限，就是用户对应的角色的权限和用户特殊直接获取的权限的并集。

#### 关于权限的传递问题

​	理论上讲，如果体量够大，角色够多，就会出现权限传递的问题。举个例子，有超级管理员，管理员，普通用户三种角色。超级管理员拥有全部权限，同时由于他拥有全部的权限，所以他可以给给任何用户授权任何权限。管理员拥有的权限比超级管理员少一些，但是他同样拥有授予权限的能力。此时，他授权的权限，只能是自己拥有的权限或者比自己拥有的权限更少！



### 二叉树的锯齿形层次遍历

```java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> ans=new LinkedList<List<Integer>>();
        if(root==null){
            return ans;
        }
        Queue<TreeNode> nodeQueue=new ArrayDeque<TreeNode>();//ArrayDeque是双端队列
        nodeQueue.offer(root);
        //这里设置一个控制变量，用来控制每次入队出队的顺序，true表示从左向右，元素加入到队尾；false表示从右向左，元素加入到队头
        boolean isOrderLeft=true;
        while(!nodeQueue.isEmpty()){
            Deque<Integer> levelList=new LinkedList<Integer>();
            int size=nodeQueue.size();
            for(int i=0;i<size;i++){
                TreeNode curNode=nodeQueue.poll();
                if(isOrderLeft){
                    levelList.offerLast(curNode.val);//此时表示从左向右，元素加入到队尾，模拟队列先进先出
                }else{
                    levelList.offerFirst(curNode.val);//此时表示从右向左，元素加入到队头，模拟栈后进先出
                }
                if(curNode.left!=null){
                    nodeQueue.offer(curNode.left);
                }
                if(curNode.right!=null){
                    nodeQueue.offer(curNode.right);
                }
            }
            ans.add(new LinkedList<Integer>(levelList));//强制类型转换
            isOrderLeft=!isOrderLeft;//每次都取反，表示每一层都反着收录数据
        }
        return ans;
    }
}
```

​	为了满足题目要求的返回值为「先从左往右，再从右往左」交替输出的锯齿形，我们可以利用「双端队列」的数据结构来维护当前层节点值输出的顺序。双端队列是一个可以在队列任意一端插入元素的队列。在广度优先搜索遍历当前层节点拓展下一层节点的时候我们仍然从左往右按顺序拓展，但是对当前层节点的存储我们维护一个变量 isOrderLeft 记录是从左至右还是从右至左的：

1.如果从左至右，我们每次将被遍历到的元素插入至双端队列的末尾。

2.如果从右至左，我们每次将被遍历到的元素插入至双端队列的头部。

​	

## 今日技巧学习及反思

### 系统分层架构学习

[系统分层架构的全面解析-CSDN博客](https://blog.csdn.net/qq_40519943/article/details/120967287)

[深入解析软件架构中的分层架构-CSDN博客](https://blog.csdn.net/cooldream2009/article/details/139801487)

​	上面两篇文章有对系统分层架构的详细说明，在完整阅读之后，个人也对系统的常见分层有了自己的一点点看法，具体内容如下文所示。

#### 为什么要分层？

​	在详细学习分层架构之前，首先需要思考一个问题，就是为什么要分层？换言之，也就是，分层有什么好处？

​	先从宏观的角度来看，分层架构是将软件模块按照水平切分的方式分成多个层级，一个系统由多层组成，每层由多个模块组成。同时，每层都有自己独立的职责，多个层次系统提供完整的功能。接着考虑分层的微观特性。分层之后，可以在业务规模增加或者流量增大时将一些模块抽离出来，独立成为一个系统，具体好处如下：

1.高内聚

​	分层的设计可以简化系统设计，让每一层专注于做某一模块的事情，这样子更加符合软件设计中的单一职责原则。

2.低耦合

​	层与层之间通过接口或者API来交互，依赖方不需要知道被依赖方的细节。

3.复用

​	分层之后可以做到很高的复用，不同的系统之间的某些层次可能是相似的，可以用来相互复用

4.扩展性

​	分层架构可以让我们更加容易做横向扩展。

#### 最常见的分层结构

​	常见的分层架构是4层，从最基础的数据库的存储支持到用户与系统之间的交互，大致可以分为4层

1.表示层

​	表示层也称为用户界面层，也就是常见的UI界面，是直接与用户交互的层。他负责处理用户的输入和输出，将系统的数据产出展示给用户，同时从用户那里接收数据的输入。表示层的职责包括用户界面展示，通过网页、桌面应用程序或者移动应用程序展示数据和界面；处理用户的各种输入，如按钮点击、表单提交等；将用户输入传递给应用层，并将应用层返回的数据展示给用户。

2.应用层

​	应用层也成为业务逻辑层，负责处理具体的业务逻辑和规则。他处理来自表示层的输入数据，并对这些数据进行处理或验证，然后调用数据访问层来获取或存储数据。应用层的职责包括业务逻辑处理，根据业务需求对输入数据进行处理和验证；将表示层的数据转换为应用层可以处理的格式，反之亦然；与数据访问层交互，以获取或存储数据。

3.数据访问层

​	数据访问层也成为持久化层，负责与数据库或其他数据存储系统进行交互。他包含用于CRUD操作的数据访问代码。数据访问层的职责包括管理数据库的连接；执行SQL查询和命令，处理结果集；将数据库中数据转换为应用层能够使用的格式。

4.数据层

​	数据层包含实际的数据存储系统，如关系型数据库、NoSQL数据库、文件系统等。数据层具体的职责包括保存应用程序所需的所有数据；保证数据的安全性和完整性，提供数据备份和数据恢复机制。



### 双端队列

​	`ArrayDeque` 是 Java 中 `java.util` 包提供的一个双端队列（Deque）实现。它是一个基于数组的可调整大小的双端队列，允许在队列的两端进行高效的插入和删除操作。`ArrayDeque` 既可以作为队列（Queue）使用，也可以作为栈（Stack）使用，并且在大多数情况下，它的性能优于传统的 `Stack` 和 `LinkedList`。

#### 主要特点

1. **双端操作**：`ArrayDeque` 允许在队列的两端进行插入和删除操作。
2. **无容量限制**：`ArrayDeque` 的容量是动态调整的，可以根据需要自动扩展。
3. **非线程安全**：`ArrayDeque` 不是线程安全的，如果在多线程环境中使用，需要进行外部同步。
4. **不允许 null 元素**：`ArrayDeque` 不允许插入 `null` 元素，因为 `null` 被用作某些方法的特殊返回值。

#### 常用方法

以下是 `ArrayDeque` 的一些常用方法：

##### 添加元素：

- `addFirst(E e)`：在队列头部添加元素。
- `addLast(E e)`：在队列尾部添加元素。
- `offerFirst(E e)`：在队列头部添加元素，成功时返回 `true`，失败时返回 `false`。
- `offerLast(E e)`：在队列尾部添加元素，成功时返回 `true`，失败时返回 `false`。

##### 移除元素：

- `removeFirst()`：移除并返回队列头部的元素，如果队列为空则抛出异常。
- `removeLast()`：移除并返回队列尾部的元素，如果队列为空则抛出异常。
- `pollFirst()`：移除并返回队列头部的元素，如果队列为空则返回 `null`。
- `pollLast()`：移除并返回队列尾部的元素，如果队列为空则返回 `null`。

##### 获取元素：

- `getFirst()`：获取队列头部的元素但不移除，如果队列为空则抛出异常。
- `getLast()`：获取队列尾部的元素但不移除，如果队列为空则抛出异常。
- `peekFirst()`：获取队列头部的元素但不移除，如果队列为空则返回 `null`。
- `peekLast()`：获取队列尾部的元素但不移除，如果队列为空则返回 `null`。

##### 栈操作：

- `push(E e)`：在栈顶（队列头部）添加元素。
- `pop()`：移除并返回栈顶（队列头部）的元素。



# 2024/12/4

## 今日工作总结

### B端账号密码登录完整逻辑

​	下面的代码是B端账号密码登录的API接口，也就是对外的登录接口定义，可通过访问/sys/auth/login来调用这个登录接口。doUserPasswdLogin是接口名字。ResponseVO<AuthLoginVO>是一个通用返回类，其中AuthLoginVO代表这个通用返回类此时的数据类型是AuthLoginVO。这个接口接收的参数是AuthPasswordLoginParamVO类型，具体内容可见代码。

```java
//B端账号密码登录的API接口，也就是对外的登录接口定义
@Tag(name = "认证模块接口API")
@RequestMapping("/sys/auth")
public interface IAuthApi {
    /**
     * B端账号密码登录
     **/
    @Operation(summary = "B端账号密码登录")
    @PostMapping("/login")
    ResponseVO<AuthLoginVO> doUserPasswdLogin(@Valid AuthPasswordLoginParamVO paramVO) throws Exception;
}
```

```java
//AuthPasswordLoginParamVO类型的具体代码
package com.jezetek.commonframework.auth.vo;

import com.jezetek.commonframework.common.vo.AbstractParamVO;
import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import lombok.Getter;
import lombok.Setter;

@Schema(description = "用户通过密码登录请求数据对象")
@Getter
@Setter
public class AuthPasswordLoginParamVO extends AbstractParamVO {
    /** 账号 */
    @Schema(description = "账号", required = true)
    @NotBlank(message = "账号不能为空")
    private String account;

    /** 密码 */
    @Schema(description = "密码", required = true)
    @NotBlank(message = "密码不能为空")
    private String password;

    /** 设备 */
    @Schema(description = "设备类型，支持:PC,APP,MINI; B端登录不指定默认是PC，C端登录必须指定")
    private String device;

    /** 验证码 */
    @Schema(description = "验证码，如果设置了验证码登录则此字段必选")
    private String validData;

    /** 验证码请求号 */
    @Schema(description = "验证码请求号，如果设置了验证码登录则此字段必选")
    private String captchaNo;
}

```

​	下面的代码是B端账号密码登录对外登录接口的实现，实现了IAuthApi中的doUserPasswdLogin接口，调用了doLogin方法进行实际的登录操作。

```java
//B端账号密码登录，对外登录接口的实现
@Override
public ResponseVO<AuthLoginVO> doUserPasswdLogin(@RequestBody @Valid AuthPasswordLoginParamVO paramVO) throws Exception {
    return ResponseVO.ok(authService.doLogin(request, response, paramVO, ClientTypeEnum.B));
}
```

​	接下来我们看看doLogin方法的标准实现定义，doLogin有一个AuthLoginVO类型的返回值，对应上方的ResponseVO<AuthLoginVO>中的AuthLoginVO类型。同时，doLogin还接收四个参数（不一定每个参数都使用了，因为框架代码本身集成了session、satoken、jwttoken三种验证方式，每种方式用到的参数不完全相同，但是，为了框架的通用性，这里将可能用到的参数全部给全）。

​	1.request表示客户端对服务器的http的请求，这个参数包括客户端发送的请求的所有信息，例如请求头、请求参数、请求方法等。

​	2.response表示服务器对客户端的http响应，这个参数可以用来设置响应的状态码、响应头、响应体等信息。

​	3.paramVO参数是用户输入的信息经过前端的处理之后返回给后端的参数，具体内容可见AuthPasswordLoginParamVO的代码。

​	4.clientTypeEnum表明用户的登录模式，因为存在B端和C端两种登录模式，这两种登录模式的代码逻辑虽然相同，但是代码细节存在差异，所以需要在接口中设置一个标识符来表明此时的登录模式是B端还是C端。

```java
//doLogin方法的标准实现定义
AuthLoginVO doLogin(HttpServletRequest request, HttpServletResponse response, AuthPasswordLoginParamVO paramVO,ClientTypeEnum clientTypeEnum) throws Exception;
```

​	接着，讲完了doLogin方法的标准实现定义，下面一层应该是doLogin方法的具体的服务实现，具体代码如下。

```java
@Override
public AuthLoginVO doLogin(HttpServletRequest request, HttpServletResponse response,AuthPasswordLoginParamVO paramVO,ClientTypeEnum clientTypeEnum) throws Exception {
    //这里是直接调用了父类的doLogin的实现方法，然后强制转化为AuthLoginVO类型进行返回,具体的继承关系可见下方
    return (AuthLoginVO) super.doLogin(request, response, paramVO, clientTypeEnum);
}
//public class AuthServiceImpl extends AbstractAuthServiceImpl implements IAuthService
//AuthServiceImpl既实现了IAuthService，同时也继承了父类AbstractAuthServiceImpl的方法
```

​	紧接着，我们需要看一看AbstractAuthServiceImpl类中到底是如何实现doLogin方法的。注意，参数中的response没有被使用。

```java
public AbstractAuthLoginVO doLogin(HttpServletRequest request, HttpServletResponse response, AuthPasswordLoginParamVO paramVO,ClientTypeEnum clientTypeEnum) throws Exception {
        log.debug("Dologin client:{} param:{}", clientTypeEnum, JSONUtil.toJsonStr(paramVO));
        //验证是否开启验证码功能
        if (captchaManageService.isEnabledCaptcha()) {
            checkCaptcha(paramVO);
        }
        //默认指定为PC，如在小程序跟移动端的情况下，自行指定即可
        if(ObjectUtil.isEmpty(paramVO.getDevice())) {
            paramVO.setDevice(AuthDeviceTypeEnum.PC.name());
        }
        //验证设备类型是否符合要求
        AuthDeviceTypeEnum.validate(paramVO.getDevice());
        //SpringContextHolder可以获得Spring容器内的Bean，这里是先得到ApplicationContext，再根据Bean的名称获取Bean，Bean的名称是userPasswdAuthPolicyServiceImpl。SpringContextHolder的详细用法请看今日技巧学习及反思。
        IAuthPolicyService policyService = (IAuthPolicyService) SpringContextHolder.getApplicationContext().getBean(getPasswordAuthPolicy());
        //根据用户的账号查询用户的信息
        IClientUserEntity userEntity = policyService.findUser(paramVO);
        //账号不存在的情况
        if (null == userEntity) {
            throw new RuntimeException("帐户:" + paramVO.getAccount() + "不存在");
        }
        //使用MD5加密算法判断用户的密码是否正确，注意，MD5加密算法是单向加密，所以对于需要验证的密码，需要给定相同的salt，再次进行加密，比较两次的加密结果是否相同，进而判断用户输入的密码是否正确。
        policyService.validateUser(userEntity, paramVO);
        //通过反射创建了一个IUserInfo类型的对象，这里主要是考虑到B端用户登录和C端用户登录使用返回的IUserInfo类型不同
        IUserInfo info = ReflectUtil.newInstance(authConfig.getUserInfoClass());
        //设置登录设备的类型
        info.setDevice(paramVO.getDevice());
        //创建一个AbstractAuthLoginVO对象，用于封装登录相关的信息，统一返回格式
        AbstractAuthLoginVO loginVO = createAuthLoginVO();
        //给info以及loginVO赋值
        fillUserLoginInfo(info, loginVO, userEntity, clientTypeEnum);
        //进行登录处理，返回authObj，里面有token
        String authObj = authContextService.doLogin(userEntity.getId(), info, request, response);
        //loginVO设置token
        loginVO.setAuthObj(authObj);
        //设置认证服务实现类型
        loginVO.setAuthService(authContextService.getClass().getSimpleName());
    	//这里调用的方法实现了数据的持久化操作，更新了用户的登录信息
        IClientUserEntity updateEntity = updateLoginInfo(userEntity, paramVO.getDevice(), CommonIpAddressUtil.getIp(request));
        //将updateEntity中的值拷贝到loginVO中
        BeanUtil.copyProperties(updateEntity, loginVO);
        //发布用户登录事件，便于后续对于登录事件的处理，可参考事件驱动架构
        if (null != publisherService) {
            UserLoginEventMessage message = AbstractEventMessage.create(UserLoginEventMessage.class, null, EventTypeEnum.EVENT_TYPE_MESSAGE);
            message.setUserId(userEntity.getId());
            message.setUserName(userEntity.getUserName());
            message.setDeviceType(clientTypeEnum.name());
            publisherService.publish(message, null);
        }

        log.debug("userId:{} userName:{} clientType:{} login successully .", loginVO.getId(), loginVO.getAccount(), clientTypeEnum);

        return loginVO;
    }
```



## 今日技巧学习及反思

### @ConditionalOnProperty注解详解

​	今天李老师提到按配置文件条件加载Spring中的Bean，用到了@ConditionalOnProperty注解，于是就去详细了解一下这个注解，没想到别有洞天，很有收获。

​	首先可以参考这篇文章，大致了解一下@ConditionalOnProperty注解[SpringBoot - @ConditionalOnProperty注解使用详解_springboot conditionalonproperty-CSDN博客](https://blog.csdn.net/goodjava2007/article/details/125536719?ops_request_misc=%7B%22request%5Fid%22%3A%229fde66e289ffde761be00e0b302fa1e1%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=9fde66e289ffde761be00e0b302fa1e1&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125536719-null-null.142^v100^pc_search_result_base3&utm_term=@ConditionalOnProperty &spm=1018.2226.3001.4187)

#### @ConditionalOnProperty注解源码

```java
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
@Documented
@Conditional({OnPropertyCondition.class})
public @interface ConditionalOnProperty {
    // NAME和VALUE的互为别名，在使用时是互斥的
    String[] value() default {};
    String[] name() default {};

	// 配置项前缀，如果完整配置为：servicex.swagger.config.enabled，则prefix为：servicex.swagger.config
    String prefix() default ""; 

	// 用havingValue与配置项的值进行对比，一致返回TRUE，不一致返回FALSE.
    String havingValue() default "";
	
	// 如果配置文件中, 没有该配置项, 判断是否加载BEAN, 默认为false。
    boolean matchIfMissing() default false;
}
```

##### name/value

​	注解的属性值value或者name二者需要选其一填写，具体填写的内容就是yml配置文件中的配置项的名称。比如下面的注解案例：

```java
@ConditionalOnProperty(name = "commonframework.test.enable",matchIfMissing = true)
//commonframework.test.enable就是yml文件中的配置项的名称，在yml文件中配置方式如下

commonframework:
  test:
    enable: true
```

##### prefix

​	prefix表示前缀，即除了最后一个开关的名称之外，剩下的配置项名称就是前缀，这个不常使用，暂不解释。

##### havingValue

​	havingValue表示配置项中的期望值，用该期望值和配置项的值进行对比，一致则返回TRUE，表示需要加载；不一致返回FALSE，表示不需要加载。

##### matchIfMissing

​	matchIfMissing表示在配置文件中，如果没有配置项，即commonframework.test.enable，那么用matchIfMissing的值判断是否加载Bean，默认为FALSE，不加载；也可以设置为TRUE，加载。

#### 特殊情况案例分析

​	特殊情况的前提是matchIfMissing的值没有配置为TRUE,同时在注解中也没有写havingValue的值。此时是否加载Bean取决于yml配置文件中的commonframework.test.enable配置项的值。配置项的值只要不为FALSE，那么就要对这个Bean进行加载，包括配置项值为空为情况。除非，yml文件中没有commonframework.test.enable配置项，此时也不会对Bean进行加载。



### 前后端统一接口返回

​	现在大多数的web项目都是前后端分离的模式，这种模式会涉及到一个前后端对接的问题，所以一套完善且规范的接口是非常必要的，不仅能提高对接效率，也能让我的代码看起来更加的简洁优雅。可以先阅读这篇文章，对前后端统一接口返回有完整的认知。[深入SpringBoot：统一接口返回和全局异常处理_springboot 捕捉异常 后beforebodywrite 失效-CSDN博客](https://blog.csdn.net/qq_47183158/article/details/123440041?ops_request_misc=&request_id=&biz_id=102&utm_term=接口 返回统一格式&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-123440041.142^v100^pc_search_result_base3&spm=1018.2226.3001.4187)

​	下面一段代码是通用对象响应类的示例，很通俗易懂，也很有学习价值。

```java
package com.jezetek.commonframework.common.vo;

import com.jezetek.commonframework.common.error.CommonErrorEnum;
import lombok.Getter;
import lombok.Setter;

import java.io.Serializable;

//@Getter和@Setter方法是Lombok提供的注解，可以自动生成get和set方法，不用自己手写
@Getter
@Setter
//这里的T是泛型编程的应用，表示当前的通用对象相应类ResponseVO可以支持各种类型的参数传入
public class ResponseVO<T> implements Serializable {
    //一般情况下，通用响应类的属性至少包含code、errMsg、data
    //其中code一般表示状态码，比如成功对应200，失败对应404等等
    //errMsg代表错误信息，也就是接口调用返回的错误信息(成功的情况可能为空)
    //data代表返回数据，也就是接口调用之后，返回数据的存储地
    private boolean result;
    private Integer code;
    private String errMsg;
    private T data;

    //注意，这个方法被static修饰，也就代表可以直接使用类名.方法名的形式调用，不需要创建实例
    //这个方法不接受参数，一般适用于没有返回值的接口调用
    public static <T> ResponseVO<T> ok() {
       return ok(null);
    }

    //这个方法有一个T类型的data参数，说明接受一个接口调用之后返回的参数，此时对result、code和data
    //进行赋值操作，最后返回包装完成的responseVO
    //该方法适用于接口调用成功，同时有返回参数的通用返回
    public static <T> ResponseVO<T> ok(T data) {
        ResponseVO<T> responseVO = new ResponseVO<>();
        responseVO.setResult(true);
        responseVO.setCode(200);
        responseVO.setData(data);

        return responseVO;
    }

    //这个方法接受错误响应码以及错误信息，可用于全局异常处理，由于是接口调用错误的通用响应类
    //所以result设置为false，code设置为错误码，errMsg设置为错误信息，data设置为null
    public static <T> ResponseVO<T> error(Integer code, String errMsg) {
        ResponseVO<T> responseVO = new ResponseVO<>();
        responseVO.setResult(false);
        responseVO.setCode(code);
        responseVO.setErrMsg(errMsg);
        responseVO.setData(null);
        return responseVO;
    }

    public static <T> ResponseVO<T> error(CommonErrorEnum errorEnum, Object[] args) {
        String errMsg = errorEnum.buildErrorMessage(args);
        return error(errorEnum.getCode(), errMsg);
    }

    @Override
    public String toString() {
        String str =  "{"
                + "\"code\": " + this.getCode()
                + ", \"errMsg\": \"" + this.getErrMsg() + "\""
                + ", \"data\": \"" + this.getData() + "\""
                + ", \"result\": \"" + this.isResult() + "\""
                + "}";

        return str;
    }
}
```



### SpringContextHolder详解

`SpringContextHolder` 是一个在Spring框架中常用的工具类，用于在应用程序的任何地方获取Spring应用上下文（`ApplicationContext`）。它的主要作用是提供一种便捷的方式来访问Spring容器中的Bean，而不需要在每个类中都注入 `ApplicationContext`。

#### 主要作用

1. **全局访问Spring上下文**：
   - `SpringContextHolder` 允许你在应用程序的任何地方（包括非Spring管理的类）获取Spring应用上下文。这对于需要在非Spring管理的类中访问Spring Bean的情况非常有用。
2. **避免重复注入**：
   - 通常情况下，你需要在每个类中注入 `ApplicationContext` 或特定的Bean。使用 `SpringContextHolder` 可以避免这种重复注入，减少代码冗余。
3. **简化Bean获取**：
   - 通过 `SpringContextHolder`，你可以直接从上下文中获取Bean，而不需要显式地注入它们。这简化了代码，使得获取Bean更加方便。

#### 实现原理

​	`SpringContextHolder` 通常是一个单例类，它持有一个静态的 `ApplicationContext` 引用。当Spring容器启动时，它会自动将 `ApplicationContext` 设置到 `SpringContextHolder` 中。这样，应用程序的任何地方都可以通过 `SpringContextHolder` 获取到 `ApplicationContext`。

​	SpringContextHolder的详细用法可以参考这篇文章：https://blog.csdn.net/qq_53943186/article/details/136606578	



# 2024/12/5

## 今日工作总结

### 登录密码校验

​	下面这段代码是登录过程中调用的密码匹配过程，给verifyPassword传入的参数中的entity是根据用户输入的账号查询得到的用户在数据库中的信息实体。loginVO则是用户输入的账号、密码、验证码等信息组成的VO，由前端封装完成发送给后端。

```Java
@Override
public void validateUser(IClientUserEntity entity, AbstractParamVO paramVO) throws Exception {
    AuthPasswordLoginParamVO loginVO = (AuthPasswordLoginParamVO)paramVO;
    if (!passwordService.verifyPassword(loginVO.getPassword(), entity.getSalt(), entity.getPasswd())) {
        throw new AuthException("登录密码不匹配");
    }
}
```

​	上方调用了verifyPassword用来判断密码是否正确，下方则是通过MD5加密之后的密码判断的具体流程。

```java
//MD5加密的判断，因为MD5加密是单向加密，所以得用同样的salt再次对用户输入的密码进行加密，然后判断新的加密结果和数据库中的正确的加密结果是否一致
@Override
public boolean verifyPassword(String planPassword, String salt, String encryptedPassword) throws Exception {
    Assert.notBlank(encryptedPassword);
    //对用户输入的密码进行加盐处理，和当初保存进入数据库使用相同的salt，再次进行加密处理
    String password = this.encryptPassword(planPassword, salt);
    //比较加密完成之后，用户输入的密码加密之后的字符串，和数据库中原本密码的加密字符串是否一致
    if (encryptedPassword.equals(password)) {
        return true;
    }
    return false;
}
```



### 添加配置完整逻辑

​	下面是添加配置的对外接口定义，属于是API定义层，接收一个由用户填写，前端封装的SysConfigAddVO类型的参数。

```java
/**
 * 添加配置
 */
@Operation(summary = "添加配置")
@PostMapping("/add")
ResponseVO<SysConfigVO> add(@Valid SysConfigAddVO sysConfigAddVO) throws Exception;
```

​	SysConfigAddVO的内容如下所示。

```java
package com.jezetek.commonframework.config.vo;

import com.jezetek.commonframework.common.vo.AbstractParamVO;
import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import lombok.Setter;

/**
 * 配置添加参数
 */
@Schema(description = "添加系统配置的请求数据对象")

@Getter
@Setter
public class SysConfigAddVO extends AbstractParamVO {

    /**
     * id
     */
    @Schema(description = "id", required = true)
    private String id;

    /**
     * 配置键
     */
    @Schema(description = "配置键", required = true)
    @NotBlank(message = "configKey不能为空")
    private String configKey;

    /**
     * 配置值
     */
    @Schema(description = "配置值", required = true)
    @NotBlank(message = "configValue不能为空")
    private String configValue;

    /**
     * 配置类型
     */
    @Schema(description = "配置类型，包括：SYS_BASE，表示系统内置；BIZ_DEFINE，表示业务配置。默认为：BIZ_DEFINE", required = true)
    private String category;

    /**
     * 备注
     */
    @Schema(description = "备注")
    private String remark;

    /**
     * 排序码
     */
    @Schema(description = "排序码", required = true)
    @NotNull(message = "sortCode不能为空")
    private Integer sortCode;

    /**
     * 扩展信息
     */
    @Schema(description = "扩展信息")
    private String extJson;
}
```

​	接着需要对API进行实现，下面的代码是对外接口的实现，即Controller。

```java
public ResponseVO<SysConfigVO> add(@RequestBody @Valid SysConfigAddVO sysConfigAddVO) throws Exception {
    /*这一行创建了一个BindingResult对象，用于存储数据绑定和验证的结果.在后续的绑定和验证过程中，如果发现任何错误（如数据格式不正确、字段缺失等），这些错误信息将被存储在 bindingResult 对象中。在后续的代码中，可以通过 bindingResult 对象的方法（如 hasErrors(), getAllErrors() 等）来检查是否有错误，并获取具体的错误信息。
    */
    BindingResult bindingResult = new BeanPropertyBindingResult(sysConfigAddVO, "sysConfigAddVO");
    return ResponseVO.ok(sysConfigService.addConfig(sysConfigAddVO, bindingResult));
}
```

​	下面的代码是addConfig的具体实现，详细解释请参考注释。

```java
@Override
//@AutoEvent是一个事件触发的注解，代表addConfig接口被访问，会触发AutoEvent内部的事件，这里不深入讨论。
@AutoEvent(eventClass = SysConfigAddEventMessage.class)
public SysConfigVO addConfig(SysConfigAddVO paramVO, BindingResult bindingResult) throws Exception {
    //这里是对前端传入的参数进行检查，检查的结果会存放在bindingResult中，checkAddParam的具体代码下方可见
    checkAddParam(paramVO, bindingResult);
    //这一步是对前端传入的参数进行检查，检查要新添加的paramVO中是否和数据库中已有的配置键重复
    persistQueryService.checkDuplicateKey(paramVO.getConfigKey());
    //paramVO的category属性检查，如果category为空，则直接默认进行赋值
    if (StrUtil.isBlank(paramVO.getCategory())) {
        paramVO.setCategory(SysConfigCategoryEnum.BIZ_DEFINE.getValue());
    }
    //将paramVO转化为数据库对应的实体类的Entity
    ISysConfigEntity entity = (ISysConfigEntity) EntityVOConvertUtil.bean2Entity(paramVO, persistService.getDataEntityClass(), getAddParam2EntityCallback());
    //将新增的数据保存到数据库中
    SysConfigVO vo = this.addEntity(entity);
    return vo;
}
```

​	下面是checkAddParam的代码，主要是通过回调检查对前端传入的参数paramVO进行检查。

```java
protected void checkAddParam(AbstractParamVO paramVO, BindingResult bindingResult) throws Exception {
    if (null != addParamCheckCallback) {
        //这一步使用回调函数对paramVO进行检查，一旦发现paramVO有问题，则会向bindingResult中设置错误，下面的hasErrors()方法就会变为true,进而将错误进行保留。
        addParamCheckCallback.paramCheckCallback(paramVO, bindingResult);
    }
    //bindingResult.hasErrors有错误，此时抛出异常
    if ((null != bindingResult) && bindingResult.hasErrors()) {
        throw new BindException(bindingResult);
    }
}
```

​	下面是checkDuplicateKey方法的具体实现，这种是在MybatisPlus下的重复检查。

```java
@Override
public void checkDuplicateKey(String key) throws Exception {
    //QueryWrapper是mp下的一个查询包装器，用于构建数据库的查询条件。SysConfigMpEntity是与数据库表对应的实体类
    QueryWrapper<SysConfigMpEntity> wrapper = new QueryWrapper<>();
    //从数据库中查询configKey值为key，也就是configKey值为paramVO.getConfigKey()的数据条目数
    wrapper.lambda().eq(SysConfigMpEntity::getConfigKey, key);
    if (this.count(wrapper) > 0) {
        throw new RuntimeException("配置键:" + key + "重复，请重新指定");
    }
}
```



## 今日技巧学习及反思

### MD5加密原理

​	有关MD5加密原理的原理，可以参考这篇文章，写的很详细：[MD5数据加密方法_md5加密-CSDN博客](https://blog.csdn.net/weixin_52115456/article/details/131827223?ops_request_misc=%7B%22request%5Fid%22%3A%22d84aad7a6e98294d372806dea36821f2%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=d84aad7a6e98294d372806dea36821f2&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-131827223-null-null.142^v100^pc_search_result_base3&utm_term=md5加密&spm=1018.2226.3001.4187)



### BindingResult和前端传值校验

​	有关BindingResult和前端传值校验，可以参考这一篇文章：[详解 BindingResult 和前端传值校验-CSDN博客](https://blog.csdn.net/pleaseprintf/article/details/131804353?ops_request_misc=%7B%22request%5Fid%22%3A%229fa86d5980c702afbc18a406876d459c%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=9fa86d5980c702afbc18a406876d459c&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-131804353-null-null.142^v100^pc_search_result_base3&utm_term=BindingResult&spm=1018.2226.3001.4187)



### QueryWrapper详解                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

​	QueryWrapper是MybatisPlus中查询包装器，具体用法可以参考这一篇文章，很详细：[MybatisPlus中QueryWrapper常用方法_mybatisplus querywrapper save-CSDN博客](https://blog.csdn.net/jinxinxin1314/article/details/131921915?ops_request_misc=%7B%22request%5Fid%22%3A%2255621fa41ae48c5a96953e7fafa5d950%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=55621fa41ae48c5a96953e7fafa5d950&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-131921915-null-null.142^v100^pc_search_result_base3&utm_term=QueryWrapper&spm=1018.2226.3001.4187)



### Validation校验参数

​	超级无敌细节的文章，Validation校验参数，一文搞定：https://blog.csdn.net/justry_deng/article/details/86571671



### @NotBlank详解

​	@NotBlank是用来验证字符串类型的属性是否为“空”，但是，他对于“空”的判断是十分严格的，属性值为null或者空的字符串（即长度为0的字符串）或者只含有空白字符（如空格、制表符等）都会被判定为“空”。

#### 1. 属性值不能为 `null`

​	如果属性值为 `null`，`@NotBlank` 注解会触发验证失败。

#### 2. 属性值不能为空字符串

​	如果属性值为空字符串（即长度为零的字符串），`@NotBlank` 注解会触发验证失败。

#### 3. 属性值不能只包含空白字符

​	如果属性值只包含空白字符（如空格、制表符等），`@NotBlank` 注解会触发验证失败。



### @NotEmpty详解

​	@NotEmpty是用来验证字符串、集合、数组或映射类型的属性是否为空。它确保这些类型的属性既不是 `null`，也不是空（即长度或大小为零）。

#### 1. 属性值不能为 `null`

​	如果属性值为 `null`，`@NotEmpty` 注解会触发验证失败。

#### 2. 字符串属性不能为空字符串

​	如果字符串属性的值为空字符串（即长度为零的字符串），`@NotEmpty` 注解会触发验证失败。

#### 3. 集合、数组或映射属性不能为空

​	如果集合、数组或映射属性的值为空（即大小为零），`@NotEmpty` 注解会触发验证失败。



### @NotNull详解

​	@NotNull用来验证属性是否为 `null`。它确保属性值不能为 `null`，但可以为空字符串、空集合、空数组等（即只要不为null即可，空字符串或者空集合、空数组都能验证成功）。

#### 1. 属性值不能为 `null`

​	如果属性值为 `null`，`@NotNull` 注解会触发验证失败。

#### 2. 属性值可以为空字符串

​	如果属性值为空字符串（即长度为零的字符串），`@NotNull` 注解不会触发验证失败。

#### 3. 属性值可以为空集合、空数组等

​	如果属性值为空集合、空数组或其他空对象，`@NotNull` 注解不会触发验证失败。



# 2024/12/6

## 今日工作总结

### 按配置文件条件加载Spring Bean

​	九洲框架提供在配置文件中条件加载Spring Bean的功能，开发过程中我们经常会集成第三方库，但是这些库中的Bean是否由Spring加载并不总是能够满足我们的需要，比如说：SaToken中，只要发现有Redis相关类存在就会自动由Spring加载启动，但是在我们的框架中，同时集成了Memory缓存和Redis缓存，通过配置开关进行切换，此时Redis的类一定存在，但是可能并没有使用Redis功能，这时SaToken的Bean自动启动会报错，为了避免这种错误的出现，需要能够根据配置文件的条件，动态选择是否加载这个Bean。现在框架中提供了统一的由配置文件中指定的条件来动态决定指定的Bean是否要加载的功能。

​	以下是使用说明：conditionBeans后面表示需要根据配置文件条件加载的Bean以及对应的加载条件。如果多个Bean需要条件加载，就需要在多个Bean之间使用分号间隔。

```yaml
commonframework:
  common:
    # 按配置条件进行加载的bean，多个bean以";"分隔，一个bean内部格式为：全路径类名[bean的全类名,key=value]，key为配置文件中的属性全路径名，value为匹配的值，当属性存在且为指定值时，bean才会加载。如果没有指定属性名和值，则认为任何条件都加载。
    conditionBeans: cn.dev33.satoken.dao.SaTokenDaoRedisJackson,commonframework.cache.type=redis
```

​	接下来看看conditionBeans是如何实现的。

```java
@Component
@Slf4j
public class ConditionBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor, EnvironmentAware {
    private Environment environment;

    @Override
    public void postProcessBeanDefinitionRegistry(@NonNull BeanDefinitionRegistry registry) throws BeansException {
        //从配置文件中获取对应的值
        String str = environment.getProperty("commonframework.common.conditionBeans");
        log.debug("postProcessBeanDefinitionRegistry process str:{}", str);
        //由于可能存在多个需要条件加载的Bean，并且他们之间是通过分号分隔的，所以先对字符串进行切割
        if (StrUtil.isNotBlank(str)) {
            String[] conditionBean = str.split(";");
           	//对切割完成的每一个Bean，都进行判断
            for (String beanStr : conditionBean) {
                try {
                    boolean inject = false;
                    String[] array = beanStr.split(",");
                    String className = array[0].trim();
                    // 如果指定了条件
                    if (array.length > 1) {
                        inject = false;
                        String[] subArray = array[1].split("=");
                        String key = subArray[0].trim();
                        String value = subArray[1].trim();
                        String envValue = environment.getProperty(key);
                        //此时表示配置文件中的键和值相等，说明需要进行加载
                        if (envValue != null && envValue.equals(value)) {
                            inject = true;
                        } else {
                            log.debug("Register bean class:{} key:{} requireValue:{} realValue:{}, not inject",
                                    className, key, value, envValue);
                        }
                    } else {
                        // 不指定条件，直接注入
                        inject = true;
                        log.debug("Register bean class:{} no condition", className);
                    }
					//注册Bean
                    if (inject) {
                        //className表示Bean的全类名
                        Class<?> clazz = Class.forName(className);
                        //Bean的名称是全类名的首字母小写
                        String beanName = StrUtil.lowerFirst(clazz.getSimpleName());
                        RootBeanDefinition beanDefinition = new RootBeanDefinition();
                        beanDefinition.setBeanClass(clazz);
                        //Bean的注册定义
                        registry.registerBeanDefinition(beanName, beanDefinition);
                        log.info("Register conditional bean:{}: class:{}", beanName, className);
                    }
                } catch (Exception e) {
                    log.error("Register conditional bean:" + beanStr + " failed", e);
                }
            }
        }
    }
}
```



## 今日技巧学习及反思

### BeanDefinitionRegistryPostProcessor

​	首先可以参考这一篇文章，内容详细：[Spring核心 - BeanDefinitionRegistryPostProcessor-CSDN博客](https://blog.csdn.net/u014365523/article/details/118683004?ops_request_misc=&request_id=&biz_id=102&utm_term=BeanDefinitionRegistryPostProc&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-118683004.142^v100^pc_search_result_base3&spm=1018.2226.3001.4187)

​	接着讲一讲自己对于BeanDefinitionRegistryPostProcessor的认知。其实很简单，就是可以条件动态的加载Bean，进而实现Bean的自定义操作。

#### 什么是 `BeanDefinitionRegistryPostProcessor`？

​	`BeanDefinitionRegistryPostProcessor` 是 Spring 框架中的一个接口，它允许你在 Spring 容器加载 Bean 定义之后、实例化 Bean 之前，对 Bean 定义进行修改或添加新的 Bean 定义。简单来说，它就像是一个“插件”，可以在 Spring 启动时对 Bean 的定义进行一些自定义操作。

#### 为什么需要 `BeanDefinitionRegistryPostProcessor`？

​	在实际开发中，有时候我们需要根据某些条件动态地决定是否加载某个 Bean，或者需要对 Bean 的定义进行一些特殊的处理。例如：

- **动态加载 Bean**：根据配置文件中的某个值，决定是否加载某个 Bean。
- **修改 Bean 定义**：在 Bean 被实例化之前，修改它的定义，比如改变它的作用域、添加依赖等。

`BeanDefinitionRegistryPostProcessor` 就是用来实现这些需求的工具。

#### 如何使用 `BeanDefinitionRegistryPostProcessor`？

1. **实现接口**：你需要创建一个类，并实现 `BeanDefinitionRegistryPostProcessor` 接口。
2. **重写方法**：实现接口中的 `postProcessBeanDefinitionRegistry` 方法，在这个方法中编写你需要的逻辑。
3. **注册 Bean**：Spring 会在启动时自动调用这个方法，你可以在方法中对 Bean 定义进行操作。

#### 举个例子

​	假设我们有一个需求：根据配置文件中的某个值，决定是否加载某个 Bean。我们可以这样做：

1. **创建一个类**：

   ```java
   @Component
   public class MyBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor {
       @Override
       public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {
           // 获取配置文件中的值，这里的environment可以用来读取配置文件中对应的值
           String loadBean = environment.getProperty("myapp.loadBean");
           // 如果配置文件中的值为 "true"，则注册一个 Bean
           if ("true".equals(loadBean)) {
               // 创建一个新的 Bean 定义
               RootBeanDefinition beanDefinition = new RootBeanDefinition();
               beanDefinition.setBeanClass(MyBean.class);
               
               // 注册这个 Bean
               registry.registerBeanDefinition("myBean", beanDefinition);
           }
       }
   }
   ```

2. **配置文件**

   ```yaml
   myapp:
     loadBean: true
   ```

​	在这个例子中，当 `myapp.loadBean` 的值为 `true` 时，Spring 会注册一个名为 `myBean` 的 Bean，它的类型是 `MyBean`。如果 `myapp.loadBean` 的值为 `false`，则不会注册这个 Bean。



### MultipartFile详解

​	参考文章：[MultipartFile工具类（方法详解）-CSDN博客](https://blog.csdn.net/weixin_45393094/article/details/112056436)



# 2024/12/7

## 今日工作总结

### 文件上传（upload）

​	经过最近两天的学习，我对于框架代码中的文件上传操作有了浅显的认知，下面先整体说说文件上传的流程，再对源码进行分析。对于一个文件上传操作而言，首先需要明确一件事情，文件一般不会直接存储在类似于MySQL的数据库中，一般会有专门存储文件的远程数据库，或者是将文件存储在服务器或者本机的外存中。本框架默认实现的文件上传机制是将文件存储在本机（可能是一台主机，也可能是一台服务器，总之就是运行当前项目的机器）的DafaultType目录下。数据库中的sys_file表其实是为了存储和文件相关的信息，比如文件的存储路径和下载路径，注意，数据库中存储文件的存储路径或者是下载路径，一般都会选择使用**相对路径**，因为文件一般是存储在服务器中，一旦文件需要在服务器中进行迁移，就只需要修改代码配置文件中的相对路径前的文件夹目录，不需要整体修改数据库的内容，这样灵活性较好，适合文件迁移。

​	首先是文件上传的对外API接口代码,即API定义层的代码，主要是对外接口的定义

```java
/**
     * 动态上传文件返回id
     **/
    @Operation(summary = "动态上传文件返回文件对象")
    @PostMapping("/upload")
    ResponseVO<FileVO> uploadFile(String engine, String bucket, @Valid @NotNull(message = "文件内容不能为空") MultipartFile file) throws Exception;
```

​	接着是对外接口的实现，即Controller层的代码。

```java
    public ResponseVO<FileVO> uploadFile(String engine, String bucket, @Valid @NotNull(message = "文件内容不能为空") @RequestPart("file") MultipartFile file) throws Exception {
        //调用文件上传的实现层方法
        FileVO fileVO = fileService.uploadFile(request, engine, bucket, file);
        return ResponseVO.ok(fileVO);
    }
```

​	紧接着是uploadFile方法的具体实现，这个方法的核心在于调用了storageFile方法，既实现了文件的存储，同时将文件存储的信息返回给FileParamVO类型的fileVO对象，便于后续对文件存储信息进行数据库持久化操作。

```java
    @Override
    @AutoEvent(eventClass = FileAddEventMessage.class)
    public FileVO uploadFile(HttpServletRequest request, String engine, String bucketName, MultipartFile file) throws Exception {
        //将文件存储在当前项目文件的DefaultType目录下，同时给fileVO赋值
        FileParamVO fileVO = storageFile(request, engine, bucketName, file);
        //下面都是数据库持久化层面的操作，不过多解释
        IAbstractEntity entity = EntityVOConvertUtil.bean2Entity(fileVO, persistService.getDataEntityClass(), getAddParam2EntityCallback());
        persistService.saveEntity(entity);
        FileVO vo = EntityVOConvertUtil.entity2Vo(entity, getVoClass(), getEntity2VoCallback());
        return vo;
    }
```

​	接下来是上传文件的核心方法，也就是storageFile方法的具体实现。

```java
    private FileParamVO storageFile(HttpServletRequest request, String engine, String bucket, MultipartFile file) throws Exception {
        //根据雪花算法随机生成一个Id(123456)
        String fileId = idWorkerService.nextIdStr();
        //为每一个文件生成一个独一无二的key(123456.jpg)
        String key = FileServiceUtil.createFileKey(fileId, file);
        //engine默认为空，所以生成的IFileStorageEngineService其实是本地存储引擎,即LocalFileStorageEngineServiceImpl
        IFileStorageEngineService storageEngineService = storageEngineManager.getStorageEngineServiceWithDefault(engine);
        //指定默认的桶名称(DefaultType)
        String bucketName = storageEngineService.getValidBucketName(bucket);
        //将文件存储到通过bucketName和key生成的存储路径（这个路径是带有文件夹的名称的），然后将文件存储到对应的存储路径上，同时返回存储路径的url（这个路径是不带有文件夹名称的）
        String storageUrl = storageEngineService.storageFileReturnUrl(bucketName, key, file);
        //对fileVO进行信息的填充
        FileParamVO fileVO = new FileParamVO();
        fileVO.setId(fileId);
        fileVO.setStorageEngine(storageEngineService.getEngineName());
        fileVO.setBucket(bucketName);
        fileVO.setFileName(file.getOriginalFilename());
        fileVO.setFileSize(file.getSize());
        String suffix = ObjectUtil.isNotEmpty(fileVO.getFileName()) ? FileUtil.getSuffix(fileVO.getFileName()) : null;
        fileVO.setSuffix(suffix);
        fileVO.setSizeInfo(FileUtil.readableFileSize(fileVO.getFileSize()));
        fileVO.setObjName(ObjectUtil.isNotEmpty(fileVO.getSuffix()) ? (fileId + StrUtil.DOT + fileVO.getSuffix()) : null);
        // 暂不实现缩略图功能
        fileVO.setThumbnail(null);
        fileVO.setStoragePath(storageUrl);

        String downloadUrl = null;
        //这里默认就是本地存储
        if (storageEngineService.isLocal()) {
            //生成下载的url
            downloadUrl = getBackendUrl(request, fileId);;
        } else {
            downloadUrl = storageUrl;
        }
        fileVO.setDownloadPath(downloadUrl);
        return fileVO;
    }
```



## 今日技巧学习及反思

### Spring的三种注入方式

​	Spring的三种注入方式：@Autowired，Setter，构造方法，可以参考：https://blog.csdn.net/qq_63218110/article/details/130266346?ops_request_misc=&request_id=&biz_id=102&utm_term=Spring%E7%9A%84%E4%B8%89%E7%A7%8D%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-5-130266346.142

​	Spring 框架中的依赖注入（Dependency Injection，简称 DI）是实现控制反转（Inversion of  Control，简称 IoC）的一种方式。通过依赖注入，Spring  容器负责将对象的依赖关系（即对象所需要的其他对象）注入到对象中，而不是让对象自己去创建或查找这些依赖。

​	Spring 提供了三种主要的依赖注入方式：构造器注入（Constructor Injection）、Setter 注入（Setter Injection）和字段注入（Field Injection）。下面我用通俗易懂的方式来解释这三种注入方式：

#### 1. 构造器注入（Constructor Injection）

​	**构造器注入**是通过类的构造函数来注入依赖。当你创建一个对象时，Spring 会自动将需要的依赖通过构造函数传递给这个对象。

​	**举个例子：**假设你有一个 `Car` 类，它需要一个 `Engine` 对象才能工作。你可以通过构造函数来注入这个 `Engine` 对象。

```java
public class Car {
    private Engine engine;

    // 构造器注入
    public Car(Engine engine) {
        this.engine = engine;
    }

    public void start() {
        engine.start();
    }
}
```

**优点：**

- **强制依赖**：构造器注入强制要求你在创建对象时必须提供所有依赖，这样可以确保对象在创建时就已经具备了所有必要的依赖。
- **不可变性**：依赖一旦注入，就不能再改变，这有助于保持对象的状态一致性。

**缺点：**

- **复杂性**：如果依赖很多，构造函数可能会变得很长，代码看起来会比较复杂。

#### 2. Setter 注入（Setter Injection）

​	**Setter 注入**是通过类的 setter 方法来注入依赖。Spring 会在对象创建后，通过调用 setter 方法来注入依赖。

​	**举个例子：**还是 `Car` 类，这次我们通过 setter 方法来注入 `Engine` 对象。

```java
public class Car {
    private Engine engine;

    // Setter 注入
    public void setEngine(Engine engine) {
        this.engine = engine;
    }

    public void start() {
        engine.start();
    }
}
```

**优点：**

- **灵活性**：Setter 注入允许你在对象创建后动态地改变依赖，这在某些场景下非常有用。
- **可选依赖**：Setter 注入可以用于注入可选的依赖，即对象可以在没有某些依赖的情况下正常工作。

**缺点：**

- **非强制性**：Setter 注入不强制要求你在创建对象时提供所有依赖，这可能会导致对象在某些情况下缺少必要的依赖。
- **可变性**：依赖可以通过 setter 方法随时改变，这可能会导致对象的状态不稳定。

#### 3. 字段注入（Field Injection）

​	**字段注入**是通过直接在类的字段上使用注解来注入依赖。Spring 会在对象创建后，直接将依赖注入到字段中。

​	**举个例子：**还是 `Car` 类，这次我们通过字段注入来注入 `Engine` 对象。

```java
import org.springframework.beans.factory.annotation.Autowired;

public class Car {
    @Autowired
    private Engine engine;

    public void start() {
        engine.start();
    }
}
```

**优点：**

- **简洁性**：字段注入的代码非常简洁，不需要写构造函数或 setter 方法。

**缺点：**

- **测试困难**：字段注入使得单元测试变得困难，因为你无法直接控制字段的值。
- **可变性**：字段注入也允许依赖随时改变，这可能会导致对象的状态不稳定。
- **强制性**：字段注入强制要求依赖必须在 Spring 容器中存在，否则会抛出异常。



# 2024/12/8

## 今日工作总结

### 文件下载

​	首先看看文件下载对应的API接口的定义。有关于ResponseEntity的详细解释，可以看今日技巧学习。InputStreamResource主要作用就是将文件的内容作为HTTP响应返回给客户端。

```java
    /**
     * 下载文件
     **/
    @Operation(summary = "下载文件")
    @GetMapping(value = "/download", produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)
    ResponseEntity<InputStreamResource> download(@Valid IdParamVO fileIdParamVO) throws Exception;
```

​	接下来是API接口的具体实现，也就是Controller层的代码。fileQueryService中的download方法是下载文件的核心代码，他所需要的参数是文件的Id，这里的Id信息，个人认为应该是用户点击选择了需要下载的文件，由前端进行查询，然后返回给后端接口。

```java
    //ResponseEntity<InputStreamResource>中的InputStreamResource会携带文件的具体信息，下载的文件存储在这里，然后返回给客户端
    @Override
    public ResponseEntity<InputStreamResource> download(IdParamVO fileIdParamVO) throws Exception {
        ResponseEntity<InputStreamResource> responseEntity = fileQueryService.download(fileIdParamVO, response);

        return responseEntity;
    }
```

​	让我们看看文件下载的核心方法，download方法。

```java
 //这个实现类中，没有用到response参数
@Override
    public ResponseEntity<InputStreamResource> download(IdParamVO fileIdParamVO, HttpServletResponse response) throws Exception {
        //先根据前端传来的Id对数据库进行查询，找到Id对应的数据库中的那一条记录，保存在entity中
        IAbstractEntity entity = persistQueryService.getExistsEntity(fileIdParamVO.getId());
        //entity转化为便于后端操作的FileVO类型
        FileVO fileVO = EntityVOConvertUtil.entity2Vo(entity, getVoClass(), getEntity2VoCallback());
        IFileStorageEngineService storageEngineService = this.storageEngineManager.getStorageEngineService(fileVO.getStorageEngine());
        if (null == storageEngineService) {
            throw new RuntimeException("文件存储引擎:" + fileVO.getStorageEngine() + "已不存在或未加载");
        }

        if (!storageEngineService.isLocal()) {
            throw new RuntimeException("本文件为非本地文件，不支持本地下载");
        }
		//根据文件信息中的桶名称和文件名称，做和上传文件一样的操作，进而找到文件的真实存储位置，将存储路径存在fullPathName中
        String fullPathName = ((LocalFileStorageEngineServiceImpl)storageEngineService).buildFilePathName(fileVO.getBucket(), fileVO.getObjName());
        //根据刚刚拼接出的文件的存储路径，将这个路径下的文件保存在File类型的file中，这里使用了hutool工具类创建文件
        File file = FileUtil.file(fullPathName);
        if (!file.exists()) {
            throw new RuntimeException("本地存储中找不到此文件，请检查是否修改过上传目录配置");
        }
        //这里主要是对文件的文件名进行一些处理，使得浏览器懂得如何下载文件
        String fileName = String.format("attachement; filename=\"%s\"", URLUtil.encode(fileVO.getFileName(), StandardCharsets.UTF_8));
        //根据fullPathName找到系统中对应的文件资源，同时将文件资源存储到FileSystemResource类型的实例中
        FileSystemResource resource = new FileSystemResource(fullPathName);
        HttpHeaders headers = new HttpHeaders();
        headers.add(HttpHeaders.CACHE_CONTROL, "no-cache,no-store,must-revalidate");
        headers.add(HttpHeaders.CONTENT_DISPOSITION, fileName);
        headers.add(HttpHeaders.PRAGMA, "no-cache");
        headers.add(HttpHeaders.EXPIRES, "0");
        headers.add(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_OCTET_STREAM + ";charset=UTF-8");
        headers.add("Access-Control-Allow-Origin", "*");
        headers.add("Access-Control-Expose-Headers", "Content-Disposition");
        //这里创建了一个包含文件内容的http响应，其中包括文件的元数据（文件大小，文件名）以及文件内容的本身
        ResponseEntity<InputStreamResource> responseEntity = ResponseEntity.ok().headers(headers)
                .contentLength(fileVO.getFileSize()).body(new InputStreamResource(resource.getInputStream()));
		//返回携带文件信息的响应实体
        return responseEntity;
    }
```



## 今日技巧学习及反思

### ResponseEntity

​	ResponseEntity是Spring框架中用于构建HTTP响应的类， 它允许开发者灵活设置响应的状态码、响应头部信息、响应体。更多关于ResponseEntity的内容可以参考这一篇文章，内容很详实：https://blog.csdn.net/m0_73837751/article/details/142936720?ops_request_misc=&request_id=&biz_id=102&utm_term=ResponseEntity&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-142936720.142

### hutool工具类

​	参考官方文档：https://www.hutool.cn/



# 2024/12/10

## 今日工作总结

### 用户认证上下文

​	本框架有关用户认证上下文的接口名是IAuthContextService，其中开发人员常用的方法有如下两个：

#### getAuthUserInfoContext

​	getAuthUserInfoContext方法是获取当前登录用户的认证信息。首先了解一下用户认证上下文的作用：在用户的账号密码被校验成功之后，将用户的认证信息，这里是IUserInfo类，存储到上下文当中（这里是存到**ThreadLocal**中），这些信息可以在后续的请求中随时获取，避免每次请求都重新查询数据库。

```java
    /**
     * 从当前线程上下文中获取用户认证信息，必须在调用之前，通过fillAuthUserInfoContextByRequest注入用户认证信息
     * @return
     * @throws Exception
     */
	IUserInfo getAuthUserInfoContext() throws Exception;
```

​	在用户的账号密码被校验成功之后，将用户的认证信息，这里是IUserInfo类，存储到上下文当中（这里是存到**ThreadLocal**中），也就是setUserInfoContext方法，这里是直接将赋值好的IUserInfo放到ThreadLocal中。类似于向map中添加值。

```java
protected static void setUserInfoContext(IUserInfo userInfo) {
    USER_INFO_HOLDER.set(userInfo);
}
```

​	接着getAuthUserInfoContext方法的具体实现，类似于从map取出值。

```java
protected static IUserInfo getUserInfoContext() {
    return USER_INFO_HOLDER.get();
}
```



#### getUserApiDataScope

​	getUserApiDataScope方法是获取当前登录用户的数据范围。

```java
/**
     * 获取当前用户的数据范围
     */
    DataScopeContext getUserApiDataScope() throws Exception;
```

​	getUserApiDataScope方法的具体实现如下：

```java
@Override
public DataScopeContext getUserApiDataScope() throws Exception {
    DataScopeContext context = null;
	//用户已经登录的情况，不需要重复添加用户信息
    IUserInfo userInfo = getUserInfoContext();
    if (null == userInfo) {
        log.warn("User not login, can not get apiDataScope .");
        return context;
    }
	//是否有超级管理员或者管理员权限，有的话数据范围就是全部可见
    if (AppUtil.hasSuperOrAdminRole(userInfo.getRoleSet())) {
        log.warn("User is superAdmin or admin, disable data scope .");
        return context;
    }
	//是否是web环境
    HttpServletRequest request = CommonServletUtil.getRequest();
    if (null == request) {
        log.warn("Request is not in web enviroment, can not get apiDataScope .");
        return context;
    }
	//获取uri，比如sys/org/add这种
    String uri = CommonServletUtil.getServletUriPath(request);
    //添加数据范围
    if (null != userInfo.getDataScope()) {
        List<String> orgIds = userInfo.getDataScope().get(uri);
        if (null != orgIds) {
            context = new DataScopeContext();
            context.setOrgIds(orgIds);
            context.setUserId(userInfo.getUserId());
        }
    }
    return context;
}
```



### 验证码自定义字符集

​	图形验证码中的字符全部来自于charSet字符集，如下所示，字符集中已经去除了一些容易混淆的字符。如果开发人员想要自定义字符集，可以自行在配置文件中修改字符集。

```java
@Value("${commonframework.auth.pictureCaptchaService.charSet:ABCDEFGHJKMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz3456789}")
private String baseStr;
```



### MapResultHandler

​	MapResultHandler可以将Mybatis的查询结果（IAbstractEntity对象）转换为Map<String, Object>的格式，并存储在一个列表中。

```java
public class MapResultHandler implements ResultHandler<IAbstractEntity> {
    //定义最终转换完成的结果列表，这个列表是由多个Map组成的列表
    private List<Map<String, Object>> result = new ArrayList<>();
    //Mybatis每次查询出来一条结果，就会调用一次handleResult方法，即对每条结果都调用toCameledMap进行类型转换的处理，然后将处理结果的map加入result列表中
    @Override
    public void handleResult(ResultContext<? extends IAbstractEntity> resultContext) {
        result.add(toCameledMap(resultContext.getResultObject()));
    }
	//返回最后的结果列表，这个列表是由多个Map组成的列表
    public List<Map<String, Object>> getResult() {
        return result;
    }
	//将Mybatis查询出的每一条记录（IAbstractEntity类型）转换为Map<String, Object>类型
    public static Map<String, Object> toCameledMap(IAbstractEntity entity) {
        Map<String, Object> resultMap = null;

        if (null != entity) {
            resultMap = new HashMap<>();
            BeanUtil.copyProperties(entity, resultMap);
        }
        return resultMap;
    }
}
```



### PageUtils

​	PageUtils工具类提供了多种分页类型之间的转换，详细见注释。

```java
public class PageUtils {
    //设置默认的分页参数
    private static Long pageSize = 10L;
    private static Long currentPage = 1L;
	//动态给定并设置分页参数
    public static void setDefault(Long size, Long page) {
        pageSize = size;
        currentPage = page;
    }
	//将分页实体(PageEntity)转化为分页对象(Page)
    public static <T> Page<T> toPage(PageEntity pageEntity) {
        Long page = currentPage;
        Long size = pageSize;
        //给page，size参数赋值
        if (null != pageEntity.getCurrentPage()) {
            page = pageEntity.getCurrentPage();
        }
        if (null != pageEntity.getPageSize()) {
            size = pageEntity.getPageSize();
        }
        //创建Page对象，同时通过构造方法初始化
        Page<T> pg = new Page<>(page, size);
        return pg;
    }

    /**
     * 适用于分页数据类型和前端展示类型相同的情况
     * @param page
     * @return
     * @param <T>
     */
    public static <T extends IAbstractEntity> PageVO<T> toPageData(IPage<T> page) {
        //将分页数据（IPage<T>）转换为前端展示的分页对象（PageVO<T>）
        PageVO<T> pageVO = new PageVO<>(page.getSize(), page.getCurrent(), page.getTotal(), page.getPages(), page.getRecords());
        return pageVO;
    }

    public static PageVO<Map<String, Object>> toPageMapData(IPage<Map<String, Object>> page) {
        //将分页数据（IPage<Map<String, Object>>）转换为前端展示的分页对象（PageVO<Map<String, Object>>）,适用于分页数据类型和前端展示类型相同的情况
        PageVO<Map<String, Object>> pageVO = new PageVO<>(page.getSize(), page.getCurrent(), page.getTotal(), page.getPages(), page.getRecords());

        return pageVO;
    }

    /**
     * 适用于分页数据类型和前端展示类型不相同的情况
     * @param page
     * @param converter
     * @param clazz
     * @return
     * @param <T>
     * @param <V>
     * @throws Exception
     */
    //注意，这个方法可以动态的传入类型转换器IBeanConverter
    public static <T, V> PageVO<V> toPageData(IPage<T> page, IBeanConverter converter, Class<V> clazz) throws Exception {
        List<V> list = new ArrayList<>();
        //类型的转换，从T类型转换为V类型
        if (ObjectUtil.isNotEmpty(page.getRecords())) {
            for (T obj : page.getRecords()) {
                V v = converter.convert(obj, clazz);
                list.add(v);
            }
        }
		//将分页数据（IPage<T>）转换为另一种类型的分页对象（PageVO<V>）
        PageVO<V> pageVO = new PageVO<>(page.getSize(), page.getCurrent(), page.getTotal(), page.getPages(), list);
        return pageVO;
    }

    //这个方法使用了系统默认完成的SimpleBeanConverter类型转换器
    public static <T, V extends AbstractVO> PageVO<V> simpleConvertPageData(IPage<T> page, Class<V> clazz) throws Exception {
        List<V> list = new ArrayList<>();
        if (ObjectUtil.isNotEmpty(page.getRecords())) {
            IBeanConverter converter = new SimpleBeanConverter();
            for (T obj : page.getRecords()) {
                V v = converter.convert(obj, clazz);
                list.add(v);
            }
        }
        //将分页数据（IPage<T>）转换为另一种类型的分页对象（PageVO<V>）
        PageVO<V> pageVO = new PageVO<>(page.getSize(), page.getCurrent(), page.getTotal(), page.getPages(), list);
        return pageVO;
    }
}
```





## 今日技巧学习及反思

### ResultHandler

​	Mybatis中的ResultHandler，可以理解为一个“结果处理器”。在每次查询数据库时，Mybatis会返回一个结果集合，可能时一个对象列表等等，使用ResultHandler，可以逐条处理这些数据，而不是一次返回一整个结果集。具体可以参考这篇文章：[Mybatis之结果处理器 - ksfzhaohui技术专栏 - SegmentFault 思否](https://segmentfault.com/a/1190000020993348)



### ThreadLocal

ThreadLocal一文理解：[史上最全ThreadLocal 详解（一）-CSDN博客](https://blog.csdn.net/u010445301/article/details/111322569)



# 2024/12/19

## 今日工作总结

### Session和Cookie

​	有关session原理的文章：https://blog.csdn.net/m0_51545690/article/details/123384986?ops_request_misc=%257B%2522request%255Fid%2522%253A%252239eee6eb1190b9ccc874c2460c6ee6e8%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=39eee6eb1190b9ccc874c2460c6ee6e8&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123384986-null-null.142

​	有关cookie原理的文章：https://blog.csdn.net/m0_51545690/article/details/123359959



## 今日技巧学习及反思

### @ConfigurationProperties注解

​	有关@ConfigurationProperties注解可以参考这一篇文章，写的十分详细：https://blog.csdn.net/xycxycooo/article/details/141197795?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522c5c096d74eaa3972dde12c4c5e991350%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=c5c096d74eaa3972dde12c4c5e991350&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-141197795-null-null.142

​	@ConfigurationProperties注解主要是从配置文件中读取属性值，同时将该属性值绑定到一个Java对象中，适合作为配置文件中的开关，来便捷的切换程序的模块。



# 2024/12/20

## 今日工作总结

### JWT登录验证

有关JWT-token的登陆验证，详细参考这篇文章[什么是JWT？(细致讲解)-CSDN博客](https://blog.csdn.net/weixin_45410366/article/details/125031959)



# 2024/12/22

## 今日技巧学习及反思

### MyBatisPlus的所有使用方法

​	MyBatisPlus的详细使用方法，一文搞定MyBatisPlus：https://blog.csdn.net/Bb15070047748/article/details/129212543?ops_request_misc=%257B%2522request%255Fid%2522%253A%25224dde96105cc56d31972e917b53e5e502%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=4dde96105cc56d31972e917b53e5e502&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-19-129212543-null-null.142



### Hutool工具类常用方法

​	Hutool工具类常用方法，一文搞定Hutool工具类：https://blog.csdn.net/abst122/article/details/124091375?ops_request_misc=&request_id=&biz_id=102&utm_term=Hutool&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-124091375.142



# 2024/12/23

## 今日工作总结





## 今日技巧学习及反思

### Spring中配置参数和依赖项的差别

​	在Spring中的setter注入中，会常常出现配置参数和依赖项注入混淆的情况，下面对二者进行分析：

```java
public interface NewsletterSender{
    //下面的setter方法中的smtpServer就是配置参数
    void setSmtpServer(String smtpServer);
    void getSmtpServer();
    void send();
}

public class setDependency{
    private Dependency dependency;
    //下面的setter方法中的dependency就是依赖项的注入
    public void setDependency(Dependency dependency){
        this.dependency=dependency;
    }
}
```

​	通常情况下，可以明确的确定是否应该将依赖项归类为配置参数，但如果不确定，配置参数有三大特征：

1.配置参数是被动的。

2.配置参数通常是信息，而不是其他的组件。

3.配置参数通常是简单值或简单值的集合。简单值指的就是基本数据类型及其封装类、字符串或这些值的集合









